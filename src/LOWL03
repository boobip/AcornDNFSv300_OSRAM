 TTL Transmit routines.                        File > LOWL03
 OPT TXRTNS


;TRANSMIT ROUTINES
;A MESSAGE IS TRANSMITTED WITH A FOUR WAY PACKET HANDSHAKE:
;A SCOUT PACKET IS TRANSMITTED
;AN ACKNOWLEGE PACKET IS AWAITED
;UPON ACKNOWLEDGE A DATA PACKET IS TRANSMITTED
;AN ACKNOWEGE PACKET IS AWAITED


;TRANSMIT     NMI SHOULD BE CLAIMED ALREADY
TRANSM
LOTRAN
 TXA
 PHA ;SAVE X REG

;COPY TXCBLOCK TO TX SCOUT AREA
 LDYIM CBSRLO
 LDAIY TXCBPT
 STA TXDELO ;DEST LO
 INY
 LDAIY TXCBPT
 STA TXDEHI ;DEST HI
 LDYIM CBCNTL
 LDAIY TXCBPT
 BMI CBLOK ;CHECK VALID CONTROL BYTE TOP BIT SET
 JMP TXCER4 ;CHECK VALID CONTROL BYTE TOP BIT SET
CBLOK
 STA TXCNTL ;CONTROL BYTE
 TAX
 INY
 LDAIY TXCBPT
 STA TXPORT ;PORT BYTE
 BNE NOTIM

 CPXIM IRTN ;CHECK IF PEEK OR POKE
 BCS NOCALC
;CALCULATE IMMEDIATE VARIABLES N.B. CHECK GOOD CONTROL BYTE
 SEC ;CALC PART OF ADDRESS FOR PEEK AND POKE
 PHP
 LDYIM CBEALO ;SUBTRACTION
LOOPP
 LDAIY TXCBPT
 DEY
 DEY ;DOWN FOUR POINT TO START ADDRESS
 DEY
 DEY
 PLP
 SBCIY TXCBPT
 STAAY TXADRF -CBSALO ;CALC EXTRA REMOTE ADDRESS
 INY
 INY
 INY ;UP FIVE TO END ADDRESS
 INY
 INY
 PHP
 CPYIM XTRA1L
 BCC LOOPP
 PLP

NOCALC
 CPXIM IPEEK ;CHECK FOR LESS THAN PEEK
 BCC TXCER4
 CPXIM IMACH + ONE ;COMPARE CONTROL BYTE
 BCS TXCER4 ;NOT VALID IM OP CONTROL BYTE
 LDYIM XTRA1L ;POINT TO CB REMOTE FROM
LP
 LDAIY TXCBPT
 STAAY TXADRT -XTRA1L ;STORE IN TX SCOUT AREA
 INY
 CPYIM XTRA2H + ONE ;COPY REMOTE FROM
 BCC LP



;CALCULATE DATA BUFFER VARIABLES
NOTIM
 LDAIM DCD ;CHECK FOR CLOCK
 BIT SReg2
 BNE TXCER3 ;NO ECONET CLOCK

;INIT CLAIM VARIABLES
 LDAIM &FD
 PHA
 LDAIM TXADRT -TXDELO
 STA ENTXCT ;STORE END COUNTER
 LDAIM ZERO
 STA TXCNT ;STORE SCOUT BUFFER COUNTER
 PHA ;STORE DELAY COUNT
 PHA
 LDYIM &E7  ;+RTS +CTXS +CRXS -TXLA TDRA FLAG 2BYT +PSE

;POLL THE ECONET BUS FOR LINE FREE
POLBUS ;N.B. COULD BE RECEIVING A PACKET,TX MUST DETECT THIS
 LDAIM RXIDLE
 PHP ;SAVE INT STATE ON STACK
 SEI ;DISABLE IRQ INTERUPT
 BIT INTOFF ;DISABLE NMI INTERUPT
 BIT INTOFF ;MAKE SURE NMI OFF COS IT NIPS IN AFTER JUST ONE
 BIT SReg2
 BEQ SKIP ;BUS IS NOT IDLE
 LDA SReg1 ;READ STATUS FIRST
 LDAIM &67 ;-RTS +CTXS +CRXS -TXL TDRA FLAG 2BYT +PSE
 STA CReg2 ;CLEAR TX AND RX STATUS
 LDAIM CTS
 BIT SReg1
 BNE CLAIM ;BUS UNDRIVEN I.E.FREE

SKIP
 BIT INTON ;ENABLE NMI INTERUPT
 PLP ;ENABLE IRQ INTERUPT
 TSX
 INCAX  &0101
 BNE POLBUS ;APPROX 10 SEC TIMEOUT LOOP
 INCAX &0102
 BNE POLBUS
 INCAX &0103
 BNE POLBUS
 BEQ TXCER0 ;LINE JAMMED OR HW FAULT

TXCER4
 LDAIM &44 ;NOT VALID CONTROL BYTE
 BNE TXCERR
;ERROR IN CLAIMING THE ECONET
TXCER0  ;LINE JAMMED
 LDAIM SEVEN ;-RTS -CTXS -CRXS -TXLA TDRA FLAG 2BYT +PSE
 STA CReg2 ;TURN OFF TX IN CASE ITS ME JAMMING
 PLA
 PLA
 PLA ;GET RID OF 3BYTE COUNT VARIABLE
 LDAIM &40
 BNE TXCERR
TXCER3
 LDAIM &43 ;NO CLOCK
TXCERR
 LDYIM CBCNTL
 STAIY TXCBPT
 LDAIM &80 ;SIGNAL CLEAR FOR USER TX
 STA TXCLRl
 PLA
 TAX ;RESTORE X
 RTS

;CLAIM THE ECONET
CLAIM
 STY CReg2  ;+RTS +CTXS +CRXS -TXLA TDRA FLAG 2BYT +PSE
 LDXIM &44  ;-TXRS +RXRS -FRDI -TDRA -RDSR +TIE -RIE SCR2
 STX CReg1  ;-TXRS +RXRS -FRDI -TDRA -RDSR +TIE -RIE SCR2
 LDXIM :LSB: WCLM
 LDYIM :MSB: WCLM
 STX TXJUMP + ONE
 STY TXJUMP + TWO ;SAVE TX JUMP ADDRESS
 SEC
 ROR TUBLOK ;SET TUBE LOCK
 BIT INTON ;ENABLE NMI INTERUPT

 LDA TXPORT ;POINT TO PORT
 BNE NTIMM ;NOT IMMED OPERATION

 LDY TXCNTL
 LDAAY NSTAT1 -IPEEK
 STA NSTATE ;STORE NSTATE
 LDAAY ENCT2 -IPEEK
 STA ENTXCT ;STORE END COUNT

; LDAAY TXIMH -IPEEK ;NIFTY CASE INSTUCTION
 LDAIM TXIMH
 PHA
 LDAAY TXIML -IPEEK
 PHA
 RTS


TXIML
 = PEEKIT - ONE
 = POKEIT - ONE
 = RTNIT - ONE
 = PROEIT - ONE
 = PROHIT - ONE
 = STOPIT - ONE
 = STRTIT - ONE
 = MACHIT - ONE

MACHIT
 LDAIM THREE ;TUBE WRITE
 BNE SKIP8
PEEKIT
 LDAIM THREE ;TUBE WRITE
 BNE SKIP7

POKEIT
 LDAIM TWO ;TUBE READ
SKIP7
 STA TDIR
 CLC
 PHP
 LDYIM XTRA1L
MRCOPY
 LDAAY TXADRF -XTRA1L ;ADDITION
 PLP
 ADCIY TXCBPT
 STAAY TXADRF -XTRA1L ;CALCULATE EXTRA REMOTE ADDRESS LO
 INY
 PHP
 CPYIM XTRA1L + FOUR
 BCC MRCOPY ; Exit condition is Y = XTRA1L + FOUR ( Y <> 0)
 PLP
 BNE CALCAD ;CALCULATE ADDRESSES, Hence a BNE here not JMP

NTIMM
 LDA TXDELO ;LOAD SOURCE ADDRESS
 AND TXDEHI
 CMPIM &FF
 BNE NOBR
 LDAIM &0E ;LENGTH OF BROADCAST SCOUT PACKET
 STA ENTXCT
 LDAIM BCAST ;FLAG BROADCAST
 STA NSTATE
 LDYIM CBSALO ;POINT TO CB REMOTE FROM
LPP
 LDAIY TXCBPT ;COPY BROADCAST PARAMETERS
 STAAY TXBUFl + TWO ;STORE IN TX SCOUT AREA
 INY
 CPYIM XTRA1L
 BCC LPP
 BCS OUT3

NOBR
 LDAIM ZERO
 STA NSTATE ;STORE STATE TO END SCOUT PACKET

RTNIT
PROEIT
PROHIT
 LDAIM TWO ;DOUBLE BYTE TUBE READ
SKIP8
 STA TDIR
CALCAD
 LDA TXCBPT
 STA RXCBPT
 LDA TXCBPT + ONE
 STA RXCBPT + ONE
 JSR ADCALC ;AND RETURN

STOPIT
STRTIT
OUT3
 PLP ;ENABLE IRQ INTERUPT
 PLA
 PLA
 PLA ;GET RID OF 3 BYTE COUNTER
 PLA
 TAX ;RESTORE X
 RTS ;RETURN TO CALLER OF TX ROUTINE. CALLER NOW POLLS.
;TX OCCURS UNDER NMI INTERUPTS


;SEND SCOUT
WCLM
 LDY TXCNT ;LOAD COUNTER
 BIT SReg1
WCLM2
 BVC TXSER1 ;TDRA EXPECTED N.B. IN 2 BYTE MODE
 LDAAY TXDELO
 STA TXBYTE
 INY
 LDAAY TXDELO
 INY
 STY TXCNT
 STA TXBYTE 
 CPY ENTXCT
 BCS ENDSCT
 BIT SReg1 ;QUICK IRQ POLL
 BMI WCLM2
 JMP WTXIN2 ;WAIT FOR TX INTERUPT


;ERROR IN TXSCOUT PACKET
TXSER2
 LDAIM &42 ;AP EXPECTED ERROR IN SCOUT ACK PACKET
 BNE SKIPIT
TXSER1
 LDAIM &67 ;-RTS +CTXST +CRXST -TXLST TDRA FLAG 2-BYT +PSE
 STA CReg2
 LDAIM &41 ;TDRA EXPECTED DUE TO COLLISION OR LINE NOISE
SKIPIT
 LDY STNID
COLARB  ;THE NOTORIOUS COLLISION ARBITRATION
 PHA
 PLA ;DELAY A BIT
 INY
 BNE COLARB
 JMP TXERRE ;JUMP TO ERROR REPORT

ENDSCT
 LDAIM &3F ;-RTS -CTXST +CRXST +TXLST FC FLAG 2-BYT +PSE
 STA CReg2
 LDAIM :LSB: ENPAK
 [ FAST5 <> TRUE
 LDYIM :MSB: ENPAK
 JMP WTXINT ;WAIT FOR PACKET TO COMPLETE
 |
 JMP WTXNTF ; New fast code !
 ]

;SCOUT TRANSMITTED
ENPAK
 LDAIM &82  ;+TXRST -RXRST -RXDISC -TDSR -RDSR -TIE +RIE SCR2
 STA CReg1
 BIT NSTATE
 BVC NOOBRD
 JMP UPTXCB
NOOBRD
 LDAIM SHORT
 BIT NSTATE
 BEQ SCTAKK
 JMP DATAK ;WAIT FOR DATA PACKET OR WAIT FOR LAST ACK PACKET

SCTAKK
 LDAIM :LSB: WSCACK
 [ FAST6 <> TRUE
 LDYIM :MSB: WSCACK
 JMP WRXINT   ;WAIT SCOUTACK PACKET
 |
 JMP WRXNTF ; New fast code !
 ]


;RECEIVE SCOUTACK PACKET
WSCACK
 LDAIM AP
 BIT SReg2
 BEQ TXSER2 ;AP EXPECTED I.E IF NOT LISTENING
 LDA RXBYTE
 CMP STNID
 BNE TXAER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WSCAKS
 [ FAST7 <> TRUE
 LDYIM :MSB: WSCAKS
 JMP WRXINT ;WAIT FOR 1 BYTE OF SOURCE
 |
 JMP WRXNTF ; New fast code !
 ]

WSCAKS  ;WAIT FOR SCOUT ACK SOURCE ADDRESS
 BIT SReg2
 BPL TXAER1 ;RXDA EXPECTED
 LDA RXBYTE ;NET NUMBER MUST BE ZERO
 BNE TXAER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WSCAKD
 [ FAST8 <> TRUE
 LDYIM :MSB: WSCAKD
 ]
 BIT SReg1 ;QUICK IRQ POLL TO SAVE TIME
 BMI WSCAKD
 [ FAST8 <> TRUE
 JMP WRXINT ;WAIT FOR 2 BYTES OF DEST
 |
 JMP WRXNTF ; New fast code !
 ]

;ERROR IN RECEIVED ACK PACKET
TXAER1  ;RXDA EXPECTED.NO MATCH ON SOUR/DEST ACK ADDR. BAD CRC
 JMP TXBER1 ;JUMP TO ERROR REPORT

WSCAKD  ;WAIT FOR SCOUT ACK DESTINATION
 BIT SReg2
 BPL TXAER1 ;RXDA EXPECTED
 LDA RXBYTE
 CMP TXDELO
 BNE TXAER1 ;NOT FROM STATION SCOUT WAS SENT TO
 LDA RXBYTE
 CMP TXDEHI
 BNE TXAER1 ;NOT FROM NET SCOUT WAS SENT TO

 LDAIM FV ;SCOUT ACK END
 BIT SReg2
 BEQ TXAER1 ;NOT FRAME VALID PACKET


;SEND DATA
 LDAIM &A7  ;+RTS -CTXST +CRXST -TXLD TDRA FLAG 2BYT +PSE
 STA CReg2  ;ENABLE TRANSMIT
 LDAIM &44  ;-TXRST +RXRST -RXDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM :LSB: DATAK
 LDYIM :MSB: DATAK
;TX 2BYTES DESTINATION
TXDATA
 STA TXLINK
 STY TXLINK + ONE
 LDA TXDELO
 BIT SReg1 ;MAY NEED DELAY HERE IF S/W TOO FAST
 BVC BCXXX2 ; TXDER1 ;TDRA EXPECTED N.B. IN 2 BYTE MODE
 STA TXBYTE ;TRANSMIT SOURCE LO
 LDA TXDEHI
 STA TXBYTE ;TRANSMIT SOURCE HI
 LDAIM :LSB: TXSR
 LDYIM :MSB: TXSR
 JMP WTXINT ;WAIT FOR TX INTERUPT

TXSR   ;TX 2BYTES SOURCE
 LDA STNID
 BIT SReg1
 BVC BCXXX2 ; TXDER1 ;TDRA EXPECTED N.B. IN 2-BYTE MODE
 STA TXBYTE ;TX STATION ID
 LDAIM NETnum
 STA TXBYTE ;TX NET ID
TXINF
 LDAIM TUBEf
 BIT NSTATE ;TEST IF DATA IS FROM TUBE
 BNE ISSTUB
 LDAIM :LSB: TXINFO
 LDYIM :MSB: TXINFO
 JMP WTXINT ;WAIT FOR TX INTERUPT
ISSTUB
 LDAIM :LSB: TXINF2
 LDYIM :MSB: TXINF2
 JMP WTXINT

;TRANSMIT DATA BYTES
TXINFO
 LDY TXYOFF
 BIT SReg1
TXINF3
BCXXX2 BVC TXDER1 ;TDRA EXPECTED N.B. IN 2-BYTE MODE, BRANCH THROUGH
 LDAIY TXDAPT
 STA TXBYTE
 INY
 BNE PASSX
 DEC TXPAGE
 BEQ TXEND2
 INC TXDAPT + ONE
PASSX
 LDAIY TXDAPT
 STA TXBYTE
 INY
 STY TXYOFF
 BNE OUTX
UPCNT
 DEC TXPAGE
 BEQ TXEND2
 INC TXDAPT + ONE
OUTX
 BIT SReg1
 BMI TXINF3 ;QUICK IRQ POLL
 JMP WTXIN2

TXEND2
 LDAIM &3F ;-RTS -CTXST +CRXST +TXLST FC FLAG 2-BYT +PSE
 STA CReg2
 LDA NSTATE
 BPL NOIM
 LDAIM :LSB: NOUPDA
 [ FAST9 <> TRUE
 LDYIM :MSB: NOUPDA
 JMP WTXINT ;WAIT FOR IMMEDIATE DATA TO COMPLETE
 |
 JMP WTXNTF ; New fast code !
 ]

NOIM
 LDA TXLINK
 LDY TXLINK + ONE
 JMP WTXINT ;WAIT FOR PACKET TO COMPLETE


;TRANSMIT DATA BYTES OF TUBE
TXINF2
 BIT SReg1
TXINF4
 BVC TXDER1 ;TDRA EXPECTED N.B. IN 2-BYTE MODE
 LDA R3DATA
 STA TXBYTE
 INC TXYOFF
 BNE CONTT2
 INC TXPAGE
 BNE CONTT2
 INC TXDAPT
 BNE CONTT2
 INC TXDAPT + ONE
 BEQ TXEND2
CONTT2
 LDA R3DATA
 STA TXBYTE
 INC TXYOFF
 BNE OUTTT
UPCN2
 INC TXPAGE
 BNE OUTTT
 INC TXDAPT
 BNE OUTTT
 INC TXDAPT + ONE
 BEQ TXEND2
OUTTT
 BIT SReg1 ;QUICK IRQ POLL
 BMI TXINF4
 JMP WTXIN2

;ERROR IN TXDATA PACKET
TXDER1
 LDA NSTATE
 BPL TXBER1 ; NOIMM ;NO LONG ACK PACKET
 JMP NOUPDA
;NOIMM ;ERROR IN TXDATA PACKET
; JMP TXBER1 ;JUMP TO ERROR REPORT

;TXEN2
DATAK
 LDAIM &82  ;+TXRST -RXRST -RXDISC -TDSR -RDSR -TIE +RIE SCR2
 STA CReg1
 LDAIM :LSB: DATACK
 [ FAST10 <> TRUE
 LDYIM :MSB: DATACK
 JMP WRXINT   ;WAIT DATA ACK PACKET
 |
 JMP WRXNTF ; New fast code !
 ]

DATACK
 LDAIM AP
 BIT SReg2
 BEQ TXBER1 ;AP EXPECTED
 LDA RXBYTE
 CMP STNID
 BNE TXBER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WDAAKS
 [ FAST11 <> TRUE
 LDYIM :MSB: WDAAKS
 JMP WRXINT ;WAIT FOR 1 BYTE OF SOURCE
 |
 JMP WRXNTF ; New fast code !
 ]

WDAAKS  ;WAIT FOR SCOUT ACK SOURCE ADDRESS
 BIT SReg2
 BPL TXBER1 ;RXDA EXPECTED
 LDA RXBYTE ;NET NUMBER MUST BE ZERO
 BNE TXBER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WDAAKD
 [ FAST12 <> TRUE
 LDYIM :MSB: WDAAKD
 ]
 BIT SReg1 ;QUICK IRQ POLL TO SAVE TIME
 BMI WDAAKD
 [ FAST12 <> TRUE
 JMP WRXINT ;WAIT FOR 2BYTES DEST
 |
 JMP WRXNTF ; New fast code !
 ]

WDAAKD  ;WAIT FOR SCOUT ACK DESTINATION
 BIT SReg2
 BPL TXBER1 ;RXDA EXPECTED
 LDA RXBYTE
 CMP TXDELO
 BNE TXBER1 ;NOT FROM STATION SCOUT WAS SENT TO
 LDA RXBYTE
 CMP TXDEHI
 BNE TXBER1 ;NOT FROM NET SCOUT WAS SENT TO

 LDA NSTATE
 BPL NODATA
 JMP RXINF
NODATA
 LDAIM FV  ;TEST FOR SCOUT ACK END
 BIT SReg2
 BEQ TXBER1 ;NOT FRAME VALID PACKET

UPTXCB
 LDAIM ZERO ;GOOD UPDATE OF TX CONTROL BYTE
 BEQ TXERRE

;ERROR IN RECEIVED DATA ACK PACKET
TXBER1
 LDAIM &41 ;AP/RXDA EXPECTED.NO MATCH ON DATA ACK SOUR/DEST ADDR.BAD CRC
TXERRE
 LDYIM CBCNTL
 STAIY TXCBPT ;STORE ERROR INDICATOR IN CNTRL BYTE
 LDAIM &80
 STA TXCLRl ;SIGNAL THAT USER CAN TX AGAIN
 JMP NOUPDA ;WAIT TO RECEIVE A NEW PACKET

ENCT2  ;LENGTH OF IMMED SCOUT BUFFERS
 = &0E ;PEEK SCOUT LENGTH
 = &0E ;POKE SCOUT LENGTH
 = &0A ;ROUTINE SCOUT LENGTH
 = &0A ;PROCEDURE EVENT SCOUT LENGTH
 = &0A ;PROCEDURE HIGH LEVEL SCOUT LENGTH
 = &06 ;STOP SCOUT LENGTH
 = &06 ;START SCOUT LENGTH
 = &0A ;MACHINE TYPE SCOUT LENGTH

NSTAT1 ;NET STATE OF IM OPS
 = &81
 = &00
 = &00
 = &00
 = &00
 = &01
 = &01
 = &81


ADCALC
 LDYIM CBSAH1
 LDAIY RXCBPT
 INY
 ANDIY RXCBPT
 CMPIM &FF ;TEST FOR TUBE ADDRESS
 BEQ NOTUB
 LDA TUBEFL ;TEST IF TUBE IS PRESENT
 BEQ NOTUB

 LDA NSTATE ;FLAG DATA IS FOR TUBE
 ORAIM TUBEf
 STA NSTATE

 SEC
 PHP
 LDYIM CBSALO   ;SET UP ADDRESSES
LOOPIT
 LDAIY RXCBPT
 INY
 INY
 INY ;UP FOUR
 INY
 PLP
 SBCIY RXCBPT
 STAAY TXYOFF -CBEALO
 DEY
 DEY ;DOWN THREE
 DEY
 PHP
 CPYIM CBEALO
 BCC LOOPIT
 PLP

 TXA
 PHA ;SAVE XREG
 LDAIM CBSALO
 CLC
 ADC RXCBPT
 TAX
 LDY RXCBPT + ONE
 LDAIM &C2
 JSR tADDRl ;CLAIM TUBE
 BCC CLBAD
 LDA TDIR
 JSR tADDRl
 JSR TUBREL ;RELEASE TUBE
 SEC ;TUBE CLAIM OK
CLBAD
 PLA
 TAX
 RTS

NOTUB
 LDYIM CBSALO
 LDAIY RXCBPT
 LDYIM CBEALO
 SEC
 SBCIY RXCBPT
 STA TXYOFF

 LDYIM CBSAHI
 LDAIY RXCBPT
 SBCIM ZERO
 STA TXDAPT + ONE

 LDYIM CBEALO
 LDAIY RXCBPT
 STA TXDAPT

 LDYIM CBEAHI
 LDAIY RXCBPT
 SEC
 SBC TXDAPT + ONE
 STA TXPAGE
 SEC ;DUMMY TUBE CLAIM OK
 RTS


 LNK LOWL04
FF VARIABLES COS IRQ IS VERY VERY SLOW
 JMP ACKSCO

RXPOKE
 LDAIM :LSB: SCOUTB
 STA RXCBPT
 LDAIM :MSB: SCOUTB ;MAKE RXCBPT POINT TO SCOUT BUFFER
 STA RXCBPT + ONE
 JMP NOBRDC
RXMACH
 LDAIM ONE ;ONE PAGE
 STA RXPAGE
 LDAIM &100 - MSIZE ;POINT TO MACHINE PEEK AREA
 STA RXYOFF
 LDAIM :LSB: (MCPEEK + MSIZE - &100)
 STA RXDAPT
 LDAIM :MSB: (MCPEEK + MSIZE - &100)
 STA RXDAPT + ONE
 [ ZERO = :MSB: (MCPEEK + MSIZE - &100)
 BEQ SENDIT
 |
 BNE SENDIT
 ]


RXPEEK
;CALCULATE RXDAPT RXYOFF RXPAGE 
 LDAIM :LSB: SCOUTB ;MAKE RXCBPT POINT TO SCOUT BUFFER
 STA RXCBPT
 LDAIM :MSB: SCOUTB
 STA RXCBPT + ONE
 LDAIM TWO ;DOUBLE BYTE WRITE
 STA TDIR
 JSR ADCALC
 BCC EXITIM ;TUBE CLAIM FAILED
SENDIT
 LDA NSTATE ;SET LONG ACK FLAG
 ORAIM &80
 STA NSTATE ;NOTE AFTER TXACK THE JUMP BACK IS DIRECT

RXSTOP
RXSTRT
 LDAIM &44  ;-TXRST +RXRST -FDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM &A7  ;+RTS -CTXST +CRXST -TXLD TDRA FLAG 2BYT +PSE
 STA CReg2  ;ENABLE TRANSMIT
 LDAIM :LSB: CIRQ
 LDYIM :MSB: CIRQ
 JMP TXACK

ENDIM
;RESTORE RXDAPT TO POINT TO PROCEDURE BUFFER

 LDA RXYOFF ;CALC PARAMETER SIZE
 CLC
 ADCIM &100 -PROBUF +&02 ;TWO ALLOWS FOR STATION NUMBER
 LDYIM BUFCNT
 STAIY DYNVC1 ;UPDATE BUFFER COUNT

 LDYIM STNNO
 LDA SBSRLO
 STAIY DYNVC1
 INY
 LDA SBSRHI
 STAIY DYNVC1 ;STORE CALLING STATION NUMBER

;CAUSE IRQ
CIRQ
 LDA SBCNTL
 STA IRQSTR ;SAVE SCOUT BUF VARIABLES COS IRQ SLOW
 LDAIM &84
 STA VIA +&E ;ENABLE SHIFT INT,IER REG
 LDA VIA +&B ;SHIFT CONTROL BY SYSTEM CLOCK,ACR REG
 ANDIM &1C
 STA STORE ;SAVE BITS 2,3,4
 LDA VIA +&B ;ACR REG
 ANDIM &E3
 ORAIM EIGHT
 STA VIA +&B ;ACR REG
 BIT VIA +&A ;READ TRIGGERS SHIFT OPERATION,SR REG
EXITIM
 JMP NOUPD2 ;GOBACK TO NORMAL RECEIVE MODE
 
; The "LOWINT" routine has been moved to LOWL01 !!!!!!!

JMPI2L  ;IMMED OP LO BYTE JUMP TABLE
 = RXRTN2 - ONE
 = RXPRE2 - ONE
 = RXPRH2 - ONE
 = RXSTP2 - ONE
 = RXSTR2 - ONE

RXRTN2
 LDAIM :MSB: (OUT - ONE)
 PHA
 LDAIM :LSB: (OUT - ONE) ;NOTE TUBE JSR IS NOT ALLOWED
 PHA
 JMI IRQSTR + ONE ;NON TUBE TYPE ROUTINE CALL

RXPRE2
 LDYIM EIGHT
 LDX IRQSTR + ONE
 LDA IRQSTR + TWO
 JSR OSEVEN ;CAUSE EVENT, ON EVENT X,Y HAS PROCEDURE NUMBER
 JMP OUT

RXPRH2 ;JUMP TO NFS
 LDX IRQSTR + ONE
 LDY IRQSTR + TWO ;LOAD X AND Y WITH PROC NUMBER
 JSR USRPRC
 JMP OUT

RXSTP2
 LDAIM STOP
 BIT SSTATE
 BNE OUT
 ORA SSTATE ;FLAG PROCESSOR IS STOPPED
 STA SSTATE
 LDAIM STOP
 CLI ;ENABLE INTERUPT
TSTSTP
 BIT SSTATE
 BNE TSTSTP ;LOOP UNTIL BIT RESET
 BEQ OUT

RXSTR2
 LDA SSTATE
 ANDIM &FF -STOP
 STA SSTATE ;CLEAR STOPPED STATE

OUT
 PLA
 TAY
 PLA
 TAX
OUT2
 LDAIM ZERO ;CLAIM IRQ
 RTS

 LNK LOWL03

H <> :MSB: (RXPOKE - ONE)
 PAGE ERROR RXPOKE
 ]
 [ JMPIMH <> :MSB: (RXRTN - ONE)
 PAGE ERROR RXRTN
 ]
 [ JMPIMH <> :MSB: (RXPROE - ONE)
 PAGE ERROR RXPROE
 ]
 [ JMPIMH <> :MSB: (RXPROH - ONE)
 PAGE ERROR RXPROH
 ]
 [ JMPIMH <> :MSB: (RXSTOP - ONE)
 PAGE ERROR RXSTOP
 ]
 [ JMPIMH <> :MSB: (RXSTRT - ONE)
 PAGE ERROR RXSTRT
 ]
 [ JMPIMH <> :MSB: (RXMACH - ONE)
 PAGE ERROR RXMACH
 ]



JMPI2H * :MSB: (RXRTN2 - ONE)
 [ JMPI2H <> :MSB: (RXPRE2 - ONE)
 PAGE ERROR RXPRE2
 ]
 [ JMPI2H <> :MSB: (RXPRH2 - ONE)
 PAGE ERROR RXPRH2
 ]
 [ JMPI2H <> :MSB: (RXSTP2 - ONE)
 PAGE ERROR RXSTP2
 ]
 [ JMPI2H <> :MSB: (RXSTR2 - ONE)
 PAGE ERROR RXSTR2
 ]



TXIMH * :MSB: (PEEKIT - ONE)
 [ TXIMH <> :MSB: (POKEIT - ONE)
 PAGE ERROR POKEIT
 ]
 [ TXIMH <> :MSB: (RTNIT - ONE)
 PAGE ERROR RTNIT
 ]
 [ TXIMH <> :MSB: (PROEIT - ONE)
 PAGE ERROR PROEIT
 ]
 [ TXIMH <> :MSB: (PROHIT - ONE)
 PAGE ERROR PROHIT
 ]
 [ TXIMH <> :MSB: (STOPIT - ONE)
 PAGE ERROR STOPIT
 ]
 [ TXIMH <> :MSB: (STRTIT - ONE)
 PAGE ERROR STRTIT
 ]
 [ TXIMH <> :MSB: (MACHIT - ONE)
 PAGE ERROR MACHIT
 ]

; ********

 [ :MSB: RXDEHI <> :MSB: REC
 [ FAST1 = TRUE
 PAGE ERROR :MSB: RXDEHI <> :MSB: REC ; FAST1 => FALSE
 ]
 |
 [ FAST1 <> TRUE
 PAGE OK :MSB: RXDEHI = :MSB: REC ; FAST1 => TRUE
 ]
 ]

; ********

 [ :MSB: RXHEAD <> :MSB: RXDEHI
 [ FAST2 = TRUE
 PAGE ERROR :MSB: RXHEAD <> :MSB: RXDEHI ; FAST2 => FALSE
 ]
 |
 [ FAST2 <> TRUE
 PAGE OK :MSB: RXHEAD = :MSB: RXDEHI ; FAST2 => TRUE
 ]
 ]

; ********

 [ :MSB: RXDAST <> :MSB: NOACK
 [ FAST3 = TRUE
 PAGE ERROR :MSB: RXDAST <> :MSB: NOACK ; FAST3 => FALSE
 ]
 |
 [ FAST3 <> TRUE
 PAGE OK :MSB: RXDAST = :MSB: NOACK ; FAST3 => TRUE
 ]
 ]

; ********

 [ :MSB: WSOUR <> :MSB: RXDAST
 [ FAST4 = TRUE
 PAGE ERROR :MSB: WSOUR <> :MSB: RXDAST ; FAST4 => FALSE
 ]
 |
 [ FAST4 <> TRUE
 PAGE OK :MSB: WSOUR = :MSB: RXDAST ; FAST4 => TRUE
 ]
 ]

; ********

 [ :MSB: ENPAK <> :MSB: WCLM
 [ FAST5 = TRUE
 PAGE ERROR :MSB: ENPAK <> :MSB: WCLM ; FAST5 => FALSE
 ]
 |
 [ FAST5 <> TRUE
 PAGE OK :MSB: ENPAK = :MSB: WCLM ; FAST5 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCACK <> :MSB: ENPAK
 [ FAST6 = TRUE
 PAGE ERROR :MSB: WSCACK <> :MSB: ENPAK ; FAST6 => FALSE
 ]
 |
 [ FAST6 <> TRUE
 PAGE OK :MSB: WSCACK = :MSB: ENPAK ; FAST6 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKS <> :MSB: WSCACK
 [ FAST7 = TRUE
 PAGE ERROR :MSB: WSCAKS <> :MSB: WSCACK ; FAST7 => FALSE
 ]
 |
 [ FAST7 <> TRUE
 PAGE OK :MSB: WSCAKS = :MSB: WSCACK ; FAST7 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKD <> :MSB: WSCAKS
 [ FAST8 = TRUE
 PAGE ERROR :MSB: WSCAKD <> :MSB: WSCAKS ; FAST8 => FALSE
 ]
 |
 [ FAST8 <> TRUE
 PAGE OK :MSB: WSCAKD = :MSB: WSCAKS ; FAST8 => TRUE
 ]
 ]

; ********

 [ FAST9 = TRUE
 [ :MSB: NOUPDA <> :MSB: TXINFO  
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINFO ; FAST9 => FALSE
 ]
 [ :MSB: NOUPDA <> :MSB: TXINF2
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINF2 ; FAST9 => FALSE
 ]
 |
 [ :MSB: NOUPDA = :MSB: TXINF2
 [ :MSB: NOUPDA = :MSB: TXINFO  
 PAGE OK :MSB: NOUPDA = :MSB: TXINFO ; FAST9 => TRUE
 PAGE OK :MSB: NOUPDA = :MSB: TXINF2 ; FAST9 => TRUE
 ]
 ]
 ]

; ********

 [ :MSB: DATACK <> :MSB: ENPAK
 [ FAST10 = TRUE
 PAGE ERROR :MSB: DATACK <> :MSB: ENPAK ; FAST10 => FALSE
 ]
 |
 [ FAST10 <> TRUE
 PAGE OK :MSB: DATACK = :MSB: ENPAK ; FAST10 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKS <> :MSB: DATACK
 [ FAST11 = TRUE
 PAGE ERROR :MSB: WDAAKS <> :MSB: DATACK ; FAST11 => FALSE
 ]
 |
 [ FAST11 <> TRUE
 PAGE OK :MSB: WDAAKS = :MSB: DATACK ; FAST11 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKD <> :MSB: WDAAKS
 [ FAST12 = TRUE
 PAGE ERROR :MSB: WDAAKD <> :MSB: WDAAKS ; FAST12 => FALSE
 ]
 |
 [ FAST12 <> TRUE
 PAGE OK :MSB: WDAAKD = :MSB: WDAAKS ; FAST12 => TRUE
 ]
 ]

 TTL ROM statistics                            File => LOWL05
 OPT STATSL

; Calculate some ROM stats

NFSLEN * NFSEND - NFSORG ; The length of the NFS
TUBLEN * TUBEND - TUBORG ; The length of the TUBE code
LOWLEN * LOWEND - LOWORG ; The length of the low level code

ZZZZZZ * NFSLEN + TUBLEN + LOWLEN ; The total size
ROMORG * NFSORG ; For saving on to disc
ROMEND * NFSORG + &4000

 END

