 TTL Non maskable interupt routines.           File => LOWL05
 OPT NMILST

NMICDE    ; NMI code is stored here

; Main interupt handling

 ORG RAMCDE

; Main interupt handler
INT   ; NMI ints enter here program routed via rx/tx jump vector
 BIT INTOFF ; Disable NMI interupt
 PHA  ; Save acumulator
 TYA
 PHA  ; Save Y register
ROMSTR
 LDAIM ZERO ; !!!!!!!Self modifying code
 STA ROMSWW ; Change over to Econet ROM
TXJUMP
RXJUMP  ; !!!!!!Self modifying code n.b. must be in RAM
 JMP REC ; Jump to receive or transmit wait address


; Main routine that waits for tx interupt
; Returns from one int waits for another tx interupt
WRXINT  ; Saves rx jump address
WTXINT  ; Saves tx jump address
 STY TXJUMP + TWO ; Store jump label
WRXNTF ; The fast version only stores the LOW byte
WTXNTF
 STA TXJUMP + ONE
WRXIN2  ; Use same jump address as last time
WTXIN2  ; Use same jump address as last time
 LDA ROMSWR ; Read old sideways ROM
 STA ROMSWW ; Restore old sideways ROM
 PLA
 TAY  ; Restore Y register
 PLA  ; Restore accumulator
 BIT INTON ; Enable NMI
 RTI  ; Return to user process


CDELEN * . - INT

LOWEND * CDELEN + NMICDE

 TTL Paging error check code                   File => LOWL05

; Do the conditional assemblys here to check for
; paging errors generated in earlier files.


JMPIMH * :MSB: (RXPEEK - ONE) ; This is the one
 [ JMPIMH <> :MSB: (RXPOKE - ONE)
 PAGE ERROR RXPOKE
 ]
 [ JMPIMH <> :MSB: (RXRTN - ONE)
 PAGE ERROR RXRTN
 ]
 [ JMPIMH <> :MSB: (RXPROE - ONE)
 PAGE ERROR RXPROE
 ]
 [ JMPIMH <> :MSB: (RXPROH - ONE)
 PAGE ERROR RXPROH
 ]
 [ JMPIMH <> :MSB: (RXSTOP - ONE)
 PAGE ERROR RXSTOP
 ]
 [ JMPIMH <> :MSB: (RXSTRT - ONE)
 PAGE ERROR RXSTRT
 ]
 [ JMPIMH <> :MSB: (RXMACH - ONE)
 PAGE ERROR RXMACH
 ]



JMPI2H * :MSB: (RXRTN2 - ONE)
 [ JMPI2H <> :MSB: (RXPRE2 - ONE)
 PAGE ERROR RXPRE2
 ]
 [ JMPI2H <> :MSB: (RXPRH2 - ONE)
 PAGE ERROR RXPRH2
 ]
 [ JMPI2H <> :MSB: (RXSTP2 - ONE)
 PAGE ERROR RXSTP2
 ]
 [ JMPI2H <> :MSB: (RXSTR2 - ONE)
 PAGE ERROR RXSTR2
 ]



TXIMH * :MSB: (PEEKIT - ONE)
 [ TXIMH <> :MSB: (POKEIT - ONE)
 PAGE ERROR POKEIT
 ]
 [ TXIMH <> :MSB: (RTNIT - ONE)
 PAGE ERROR RTNIT
 ]
 [ TXIMH <> :MSB: (PROEIT - ONE)
 PAGE ERROR PROEIT
 ]
 [ TXIMH <> :MSB: (PROHIT - ONE)
 PAGE ERROR PROHIT
 ]
 [ TXIMH <> :MSB: (STOPIT - ONE)
 PAGE ERROR STOPIT
 ]
 [ TXIMH <> :MSB: (STRTIT - ONE)
 PAGE ERROR STRTIT
 ]
 [ TXIMH <> :MSB: (MACHIT - ONE)
 PAGE ERROR MACHIT
 ]

; ********

 [ :MSB: RXDEHI <> :MSB: REC
 [ FAST1 = TRUE
 PAGE ERROR :MSB: RXDEHI <> :MSB: REC ; FAST1 => FALSE
 ]
 |
 [ FAST1 <> TRUE
 PAGE OK :MSB: RXDEHI = :MSB: REC ; FAST1 => TRUE
 ]
 ]

; ********

 [ :MSB: RXHEAD <> :MSB: RXDEHI
 [ FAST2 = TRUE
 PAGE ERROR :MSB: RXHEAD <> :MSB: RXDEHI ; FAST2 => FALSE
 ]
 |
 [ FAST2 <> TRUE
 PAGE OK :MSB: RXHEAD = :MSB: RXDEHI ; FAST2 => TRUE
 ]
 ]

; ********

 [ :MSB: RXDAST <> :MSB: NOACK
 [ FAST3 = TRUE
 PAGE ERROR :MSB: RXDAST <> :MSB: NOACK ; FAST3 => FALSE
 ]
 |
 [ FAST3 <> TRUE
 PAGE OK :MSB: RXDAST = :MSB: NOACK ; FAST3 => TRUE
 ]
 ]

; ********

 [ :MSB: WSOUR <> :MSB: RXDAST
 [ FAST4 = TRUE
 PAGE ERROR :MSB: WSOUR <> :MSB: RXDAST ; FAST4 => FALSE
 ]
 |
 [ FAST4 <> TRUE
 PAGE OK :MSB: WSOUR = :MSB: RXDAST ; FAST4 => TRUE
 ]
 ]

; ********

 [ :MSB: ENPAK <> :MSB: WCLM
 [ FAST5 = TRUE
 PAGE ERROR :MSB: ENPAK <> :MSB: WCLM ; FAST5 => FALSE
 ]
 |
 [ FAST5 <> TRUE
 PAGE OK :MSB: ENPAK = :MSB: WCLM ; FAST5 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCACK <> :MSB: ENPAK
 [ FAST6 = TRUE
 PAGE ERROR :MSB: WSCACK <> :MSB: ENPAK ; FAST6 => FALSE
 ]
 |
 [ FAST6 <> TRUE
 PAGE OK :MSB: WSCACK = :MSB: ENPAK ; FAST6 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKS <> :MSB: WSCACK
 [ FAST7 = TRUE
 PAGE ERROR :MSB: WSCAKS <> :MSB: WSCACK ; FAST7 => FALSE
 ]
 |
 [ FAST7 <> TRUE
 PAGE OK :MSB: WSCAKS = :MSB: WSCACK ; FAST7 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKD <> :MSB: WSCAKS
 [ FAST8 = TRUE
 PAGE ERROR :MSB: WSCAKD <> :MSB: WSCAKS ; FAST8 => FALSE
 ]
 |
 [ FAST8 <> TRUE
 PAGE OK :MSB: WSCAKD = :MSB: WSCAKS ; FAST8 => TRUE
 ]
 ]

; ********

 [ FAST9 = TRUE
 [ :MSB: NOUPDA <> :MSB: TXINFO  
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINFO ; FAST9 => FALSE
 ]
 [ :MSB: NOUPDA <> :MSB: TXINF2
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINF2 ; FAST9 => FALSE
 ]
 |
 [ :MSB: NOUPDA = :MSB: TXINF2
 [ :MSB: NOUPDA = :MSB: TXINFO  
 PAGE OK :MSB: NOUPDA = :MSB: TXINFO ; FAST9 => TRUE
 PAGE OK :MSB: NOUPDA = :MSB: TXINF2 ; FAST9 => TRUE
 ]
 ]
 ]

; ********

 [ :MSB: DATACK <> :MSB: ENPAK
 [ FAST10 = TRUE
 PAGE ERROR :MSB: DATACK <> :MSB: ENPAK ; FAST10 => FALSE
 ]
 |
 [ FAST10 <> TRUE
 PAGE OK :MSB: DATACK = :MSB: ENPAK ; FAST10 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKS <> :MSB: DATACK
 [ FAST11 = TRUE
 PAGE ERROR :MSB: WDAAKS <> :MSB: DATACK ; FAST11 => FALSE
 ]
 |
 [ FAST11 <> TRUE
 PAGE OK :MSB: WDAAKS = :MSB: DATACK ; FAST11 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKD <> :MSB: WDAAKS
 [ FAST12 = TRUE
 PAGE ERROR :MSB: WDAAKD <> :MSB: WDAAKS ; FAST12 => FALSE
 ]
 |
 [ FAST12 <> TRUE
 PAGE OK :MSB: WDAAKD = :MSB: WDAAKS ; FAST12 => TRUE
 ]
 ]

 TTL ROM statistics                            File => LOWL05
 OPT STATSL

; Calculate some ROM stats

NFSLEN * NFSEND - NFSORG ; The length of the NFS
TUBLEN * TUBEND - TUBORG ; The length of the TUBE code
LOWLEN * LOWEND - LOWORG ; The length of the low level code

ZZZZZZ * NFSLEN + TUBLEN + LOWLEN ; The total size
ROMORG * NFSORG ; For saving on to disc
ROMEND * NFSORG + &4000

 END

LA ;DELAY A BIT
 INY
 BNE COLARB
 JMP TXERRE ;JUMP TO ERROR REPORT

ENDSCT
 LDAIM &3F ;-RTS -CTXST +CRXST +TXLST FC FLAG 2-BYT +PSE
 STA CReg2
 LDAIM :LSB: ENPAK
 [ FAST5 <> TRUE
 LDYIM :MSB: ENPAK
 JMP WTXINT ;WAIT FOR PACKET TO COMPLETE
 |
 JMP WTXNTF ; New fast code !
 ]

;SCOUT TRANSMITTED
ENPAK
 LDAIM &82  ;+TXRST -RXRST -RXDISC -TDSR -RDSR -TIE +RIE SCR2
 STA CReg1
 BIT NSTATE
 BVC NOOBRD
 JMP UPTXCB
NOOBRD
 LDAIM SHORT
 BIT NSTATE
 BEQ SCTAKK
 JMP DATAK ;WAIT FOR DATA PACKET OR WAIT FOR LAST ACK PACKET

SCTAKK
 LDAIM :LSB: WSCACK
 [ FAST6 <> TRUE
 LDYIM :MSB: WSCACK
 JMP WRXINT   ;WAIT SCOUTACK PACKET
 |
 JMP WRXNTF ; New fast code !
 ]


;RECEIVE SCOUTACK PACKET
WSCACK
 LDAIM AP
 BIT SReg2
 BEQ TXSER2 ;AP EXPECTED I.E IF NOT LISTENING
 LDA RXBYTE
 CMP STNID
 BNE TXAER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WSCAKS
 [ FAST7 <> TRUE
 LDYIM :MSB: WSCAKS
 JMP WRXINT ;WAIT FOR 1 BYTE OF SOURCE
 |
 JMP WRXNTF ; New fast code !
 ]

WSCAKS  ;WAIT FOR SCOUT ACK SOURCE ADDRESS
 BIT SReg2
 BPL TXAER1 ;RXDA EXPECTED
 LDA RXBYTE ;NET NUMBER MUST BE ZERO
 BNE TXAER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WSCAKD
 [ FAST8 <> TRUE
 LDYIM :MSB: WSCAKD
 ]
 BIT SReg1 ;QUICK IRQ POLL TO SAVE TIME
 BMI WSCAKD
 [ FAST8 <> TRUE
 JMP WRXINT ;WAIT FOR 2 BYTES OF DEST
 |
 JMP WRXNTF ; New fast code !
 ]

;ERROR IN RECEIVED ACK PACKET
TXAER1  ;RXDA EXPECTED.NO MATCH ON SOUR/DEST ACK ADDR. BAD CRC
 JMP TXBER1 ;JUMP TO ERROR REPORT

WSCAKD  ;WAIT FOR SCOUT ACK DESTINATION
 BIT SReg2
 BPL TXAER1 ;RXDA EXPECTED
 LDA RXBYTE
 CMP TXDELO
 BNE TXAER1 ;NOT FROM STATION SCOUT WAS SENT TO
 LDA RXBYTE
 CMP TXDEHI
 BNE TXAER1 ;NOT FROM NET SCOUT WAS SENT TO

 LDAIM FV ;SCOUT ACK END
 BIT SReg2
 BEQ TXAER1 ;NOT FRAME VALID PACKET


;SEND DATA
 LDAIM &A7  ;+RTS -CTXST +CRXST -TXLD TDRA FLAG 2BYT +PSE
 STA CReg2  ;ENABLE TRANSMIT
 LDAIM &44  ;-TXRST +RXRST -RXDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM :LSB: DATAK
 LDYIM :MSB: DATAK
;TX 2BYTES DESTINATION
TXDATA
 STA TXLINK
 STY TXLINK + ONE
 LDA TXDELO
 BIT SReg1 ;MAY NEED DELAY HERE IF S/W TOO FAST
 BVC BCXXX2 ; TXDER1 ;TDRA EXPECTED N.B. IN 2 BYTE MODE
 STA TXBYTE ;TRANSMIT SOURCE LO
 LDA TXDEHI
 STA TXBYTE ;TRANSMIT SOURCE HI
 LDAIM :LSB: TXSR
 LDYIM :MSB: TXSR
 JMP WTXINT ;WAIT FOR TX INTERUPT

TXSR   ;TX 2BYTES SOURCE
 LDA STNID
 BIT SReg1
 BVC BCXXX2 ; TXDER1 ;TDRA EXPECTED N.B. IN 2-BYTE MODE
 STA TXBYTE ;TX STATION ID
 LDAIM NETnum
 STA TXBYTE ;TX NET ID
TXINF
 LDAIM TUBEf
 BIT NSTATE ;TEST IF DATA IS FROM TUBE
 BNE ISSTUB
 LDAIM :LSB: TXINFO
 LDYIM :MSB: TXINFO
 JMP WTXINT ;WAIT FOR TX INTERUPT
ISSTUB
 LDAIM :LSB: TXINF2
 LDYIM :MSB: TXINF2
 JMP WTXINT

;TRANSMIT DATA BYTES
TXINFO
 LDY TXYOFF
 BIT SReg1
TXINF3
BCXXX2 BVC TXDER1 ;TDRA EXPECTED N.B. IN 2-BYTE MODE, BRANCH THROUGH
 LDAIY TXDAPT
 STA TXBYTE
 INY
 BNE PASSX
 DEC TXPAGE
 BEQ TXEND2
 INC TXDAPT + ONE
PASSX
 LDAIY TXDAPT
 STA TXBYTE
 INY
 STY TXYOFF
 BNE OUTX
UPCNT
 DEC TXPAGE
 BEQ TXEND2
 INC TXDAPT + ONE
OUTX
 BIT SReg1
 BMI TXINF3 ;QUICK IRQ POLL
 JMP WTXIN2

TXEND2
 LDAIM &3F ;-RTS -CTXST +CRXST +TXLST FC FLAG 2-BYT +PSE
 STA CReg2
 LDA NSTATE
 BPL NOIM
 LDAIM :LSB: NOUPDA
 [ FAST9 <> TRUE
 LDYIM :MSB: NOUPDA
 JMP WTXINT ;WAIT FOR IMMEDIATE DATA TO COMPLETE
 |
 JMP WTXNTF ; New fast code !
 ]

NOIM
 LDA TXLINK
 LDY TXLINK + ONE
 JMP WTXINT ;WAIT FOR PACKET TO COMPLETE


;TRANSMIT DATA BYTES OF TUBE
TXINF2
 BIT SReg1
TXINF4
 BVC TXDER1 ;TDRA EXPECTED N.B. IN 2-BYTE MODE
 LDA R3DATA
 STA TXBYTE
 INC TXYOFF
 BNE CONTT2
 INC TXPAGE
 BNE CONTT2
 INC TXDAPT
 BNE CONTT2
 INC TXDAPT + ONE
 BEQ TXEND2
CONTT2
 LDA R3DATA
 STA TXBYTE
 INC TXYOFF
 BNE OUTTT
UPCN2
 INC TXPAGE
 BNE OUTTT
 INC TXDAPT
 BNE OUTTT
 INC TXDAPT + ONE
 BEQ TXEND2
OUTTT
 BIT SReg1 ;QUICK IRQ POLL
 BMI TXINF4
 JMP WTXIN2

;ERROR IN TXDATA PACKET
TXDER1
 LDA NSTATE
 BPL TXBER1 ; NOIMM ;NO LONG ACK PACKET
 JMP NOUPDA
;NOIMM ;ERROR IN TXDATA PACKET
; JMP TXBER1 ;JUMP TO ERROR REPORT

;TXEN2
DATAK
 LDAIM &82  ;+TXRST -RXRST -RXDISC -TDSR -RDSR -TIE +RIE SCR2
 STA CReg1
 LDAIM :LSB: DATACK
 [ FAST10 <> TRUE
 LDYIM :MSB: DATACK
 JMP WRXINT   ;WAIT DATA ACK PACKET
 |
 JMP WRXNTF ; New fast code !
 ]

DATACK
 LDAIM AP
 BIT SReg2
 BEQ TXBER1 ;AP EXPECTED
 LDA RXBYTE
 CMP STNID
 BNE TXBER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WDAAKS
 [ FAST11 <> TRUE
 LDYIM :MSB: WDAAKS
 JMP WRXINT ;WAIT FOR 1 BYTE OF SOURCE
 |
 JMP WRXNTF ; New fast code !
 ]

WDAAKS  ;WAIT FOR SCOUT ACK SOURCE ADDRESS
 BIT SReg2
 BPL TXBER1 ;RXDA EXPECTED
 LDA RXBYTE ;NET NUMBER MUST BE ZERO
 BNE TXBER1 ;NO SOURCE ADDRESS MATCH
 LDAIM :LSB: WDAAKD
 [ FAST12 <> TRUE
 LDYIM :MSB: WDAAKD
 ]
 BIT SReg1 ;QUICK IRQ POLL TO SAVE TIME
 BMI WDAAKD
 [ FAST12 <> TRUE
 JMP WRXINT ;WAIT FOR 2BYTES DEST
 |
 JMP WRXNTF ; New fast code !
 ]

WDAAKD  ;WAIT FOR SCOUT ACK DESTINATION
 BIT SReg2
 BPL TXBER1 ;RXDA EXPECTED
 LDA RXBYTE
 CMP TXDELO
 BNE TXBER1 ;NOT FROM STATION SCOUT WAS SENT TO
 LDA RXBYTE
 CMP TXDEHI
 BNE TXBER1 ;NOT FROM NET SCOUT WAS SENT TO

 LDA NSTATE
 BPL NODATA
 JMP RXINF
NODATA
 LDAIM FV  ;TEST FOR SCOUT ACK END
 BIT SReg2
 BEQ TXBER1 ;NOT FRAME VALID PACKET

UPTXCB
 LDAIM ZERO ;GOOD UPDATE OF TX CONTROL BYTE
 BEQ TXERRE

;ERROR IN RECEIVED DATA ACK PACKET
TXBER1
 LDAIM &41 ;AP/RXDA EXPECTED.NO MATCH ON DATA ACK SOUR/DEST ADDR.BAD CRC
TXERRE
 LDYIM CBCNTL
 STAIY TXCBPT ;STORE ERROR INDICATOR IN CNTRL BYTE
 LDAIM &80
 STA TXCLRl ;SIGNAL THAT USER CAN TX AGAIN
 JMP NOUPDA ;WAIT TO RECEIVE A NEW PACKET

ENCT2  ;LENGTH OF IMMED SCOUT BUFFERS
 = &0E ;PEEK SCOUT LENGTH
 = &0E ;POKE SCOUT LENGTH
 = &0A ;ROUTINE SCOUT LENGTH
 = &0A ;PROCEDURE EVENT SCOUT LENGTH
 = &0A ;PROCEDURE HIGH LEVEL SCOUT LENGTH
 = &06 ;STOP SCOUT LENGTH
 = &06 ;START SCOUT LENGTH
 = &0A ;MACHINE TYPE SCOUT LENGTH

NSTAT1 ;NET STATE OF IM OPS
 = &81
 = &00
 = &00
 = &00
 = &00
 = &01
 = &01
 = &81


ADCALC
 LDYIM CBSAH1
 LDAIY RXCBPT
 INY
 ANDIY RXCBPT
 CMPIM &FF ;TEST FOR TUBE ADDRESS
 BEQ NOTUB
 LDA TUBEFL ;TEST IF TUBE IS PRESENT
 BEQ NOTUB

 LDA NSTATE ;FLAG DATA IS FOR TUBE
 ORAIM TUBEf
 STA NSTATE

 SEC
 PHP
 LDYIM CBSALO   ;SET UP ADDRESSES
LOOPIT
 LDAIY RXCBPT
 INY
 INY
 INY ;UP FOUR
 INY
 PLP
 SBCIY RXCBPT
 STAAY TXYOFF -CBEALO
 DEY
 DEY ;DOWN THREE
 DEY
 PHP
 CPYIM CBEALO
 BCC LOOPIT
 PLP

 TXA
 PHA ;SAVE XREG
 LDAIM CBSALO
 CLC
 ADC RXCBPT
 TAX
 LDY RXCBPT + ONE
 LDAIM &C2
 JSR tADDRl ;CLAIM TUBE
 BCC CLBAD
 LDA TDIR
 JSR tADDRl
 JSR TUBREL ;RELEASE TUBE
 SEC ;TUBE CLAIM OK
CLBAD
 PLA
 TAX
 RTS

NOTUB
 LDYIM CBSALO
 LDAIY RXCBPT
 LDYIM CBEALO
 SEC
 SBCIY RXCBPT
 STA TXYOFF

 LDYIM CBSAHI
 LDAIY RXCBPT
 SBCIM ZERO
 STA TXDAPT + ONE

 LDYIM CBEALO
 LDAIY RXCBPT
 STA TXDAPT

 LDYIM CBEAHI
 LDAIY RXCBPT
 SEC
 SBC TXDAPT + ONE
 STA TXPAGE
 SEC ;DUMMY TUBE CLAIM OK
 RTS


 LNK LOWL04
FF VARIABLES COS IRQ IS VERY VERY SLOW
 JMP ACKSCO

RXPOKE
 LDAIM :LSB: SCOUTB
 STA RXCBPT
 LDAIM :MSB: SCOUTB ;MAKE RXCBPT POINT TO SCOUT BUFFER
 STA RXCBPT + ONE
 JMP NOBRDC
RXMACH
 LDAIM ONE ;ONE PAGE
 STA RXPAGE
 LDAIM &100 - MSIZE ;POINT TO MACHINE PEEK AREA
 STA RXYOFF
 LDAIM :LSB: (MCPEEK + MSIZE - &100)
 STA RXDAPT
 LDAIM :MSB: (MCPEEK + MSIZE - &100)
 STA RXDAPT + ONE
 [ ZERO = :MSB: (MCPEEK + MSIZE - &100)
 BEQ SENDIT
 |
 BNE SENDIT
 ]


RXPEEK
;CALCULATE RXDAPT RXYOFF RXPAGE 
 LDAIM :LSB: SCOUTB ;MAKE RXCBPT POINT TO SCOUT BUFFER
 STA RXCBPT
 LDAIM :MSB: SCOUTB
 STA RXCBPT + ONE
 LDAIM TWO ;DOUBLE BYTE WRITE
 STA TDIR
 JSR ADCALC
 BCC EXITIM ;TUBE CLAIM FAILED
SENDIT
 LDA NSTATE ;SET LONG ACK FLAG
 ORAIM &80
 STA NSTATE ;NOTE AFTER TXACK THE JUMP BACK IS DIRECT

RXSTOP
RXSTRT
 LDAIM &44  ;-TXRST +RXRST -FDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM &A7  ;+RTS -CTXST +CRXST -TXLD TDRA FLAG 2BYT +PSE
 STA CReg2  ;ENABLE TRANSMIT
 LDAIM :LSB: CIRQ
 LDYIM :MSB: CIRQ
 JMP TXACK

ENDIM
;RESTORE RXDAPT TO POINT TO PROCEDURE BUFFER

 LDA RXYOFF ;CALC PARAMETER SIZE
 CLC
 ADCIM &100 -PROBUF +&02 ;TWO ALLOWS FOR STATION NUMBER
 LDYIM BUFCNT
 STAIY DYNVC1 ;UPDATE BUFFER COUNT

 LDYIM STNNO
 LDA SBSRLO
 STAIY DYNVC1
 INY
 LDA SBSRHI
 STAIY DYNVC1 ;STORE CALLING STATION NUMBER

;CAUSE IRQ
CIRQ
 LDA SBCNTL
 STA IRQSTR ;SAVE SCOUT BUF VARIABLES COS IRQ SLOW
 LDAIM &84
 STA VIA +&E ;ENABLE SHIFT INT,IER REG
 LDA VIA +&B ;SHIFT CONTROL BY SYSTEM CLOCK,ACR REG
 ANDIM &1C
 STA STORE ;SAVE BITS 2,3,4
 LDA VIA +&B ;ACR REG
 ANDIM &E3
 ORAIM EIGHT
 STA VIA +&B ;ACR REG
 BIT VIA +&A ;READ TRIGGERS SHIFT OPERATION,SR REG
EXITIM
 JMP NOUPD2 ;GOBACK TO NORMAL RECEIVE MODE
 
; The "LOWINT" routine has been moved to LOWL01 !!!!!!!

JMPI2L  ;IMMED OP LO BYTE JUMP TABLE
 = RXRTN2 - ONE
 = RXPRE2 - ONE
 = RXPRH2 - ONE
 = RXSTP2 - ONE
 = RXSTR2 - ONE

RXRTN2
 LDAIM :MSB: (OUT - ONE)
 PHA
 LDAIM :LSB: (OUT - ONE) ;NOTE TUBE JSR IS NOT ALLOWED
 PHA
 JMI IRQSTR + ONE ;NON TUBE TYPE ROUTINE CALL

RXPRE2
 LDYIM EIGHT
 LDX IRQSTR + ONE
 LDA IRQSTR + TWO
 JSR OSEVEN ;CAUSE EVENT, ON EVENT X,Y HAS PROCEDURE NUMBER
 JMP OUT

RXPRH2 ;JUMP TO NFS
 LDX IRQSTR + ONE
 LDY IRQSTR + TWO ;LOAD X AND Y WITH PROC NUMBER
 JSR USRPRC
 JMP OUT

RXSTP2
 LDAIM STOP
 BIT SSTATE
 BNE OUT
 ORA SSTATE ;FLAG PROCESSOR IS STOPPED
 STA SSTATE
 LDAIM STOP
 CLI ;ENABLE INTERUPT
TSTSTP
 BIT SSTATE
 BNE TSTSTP ;LOOP UNTIL BIT RESET
 BEQ OUT

RXSTR2
 LDA SSTATE
 ANDIM &FF -STOP
 STA SSTATE ;CLEAR STOPPED STATE

OUT
 PLA
 TAY
 PLA
 TAX
OUT2
 LDAIM ZERO ;CLAIM IRQ
 RTS

 LNK LOWL03

H <> :MSB: (RXPOKE - ONE)
 PAGE ERROR RXPOKE
 ]
 [ JMPIMH <> :MSB: (RXRTN - ONE)
 PAGE ERROR RXRTN
 ]
 [ JMPIMH <> :MSB: (RXPROE - ONE)
 PAGE ERROR RXPROE
 ]
 [ JMPIMH <> :MSB: (RXPROH - ONE)
 PAGE ERROR RXPROH
 ]
 [ JMPIMH <> :MSB: (RXSTOP - ONE)
 PAGE ERROR RXSTOP
 ]
 [ JMPIMH <> :MSB: (RXSTRT - ONE)
 PAGE ERROR RXSTRT
 ]
 [ JMPIMH <> :MSB: (RXMACH - ONE)
 PAGE ERROR RXMACH
 ]



JMPI2H * :MSB: (RXRTN2 - ONE)
 [ JMPI2H <> :MSB: (RXPRE2 - ONE)
 PAGE ERROR RXPRE2
 ]
 [ JMPI2H <> :MSB: (RXPRH2 - ONE)
 PAGE ERROR RXPRH2
 ]
 [ JMPI2H <> :MSB: (RXSTP2 - ONE)
 PAGE ERROR RXSTP2
 ]
 [ JMPI2H <> :MSB: (RXSTR2 - ONE)
 PAGE ERROR RXSTR2
 ]



TXIMH * :MSB: (PEEKIT - ONE)
 [ TXIMH <> :MSB: (POKEIT - ONE)
 PAGE ERROR POKEIT
 ]
 [ TXIMH <> :MSB: (RTNIT - ONE)
 PAGE ERROR RTNIT
 ]
 [ TXIMH <> :MSB: (PROEIT - ONE)
 PAGE ERROR PROEIT
 ]
 [ TXIMH <> :MSB: (PROHIT - ONE)
 PAGE ERROR PROHIT
 ]
 [ TXIMH <> :MSB: (STOPIT - ONE)
 PAGE ERROR STOPIT
 ]
 [ TXIMH <> :MSB: (STRTIT - ONE)
 PAGE ERROR STRTIT
 ]
 [ TXIMH <> :MSB: (MACHIT - ONE)
 PAGE ERROR MACHIT
 ]

; ********

 [ :MSB: RXDEHI <> :MSB: REC
 [ FAST1 = TRUE
 PAGE ERROR :MSB: RXDEHI <> :MSB: REC ; FAST1 => FALSE
 ]
 |
 [ FAST1 <> TRUE
 PAGE OK :MSB: RXDEHI = :MSB: REC ; FAST1 => TRUE
 ]
 ]

; ********

 [ :MSB: RXHEAD <> :MSB: RXDEHI
 [ FAST2 = TRUE
 PAGE ERROR :MSB: RXHEAD <> :MSB: RXDEHI ; FAST2 => FALSE
 ]
 |
 [ FAST2 <> TRUE
 PAGE OK :MSB: RXHEAD = :MSB: RXDEHI ; FAST2 => TRUE
 ]
 ]

; ********

 [ :MSB: RXDAST <> :MSB: NOACK
 [ FAST3 = TRUE
 PAGE ERROR :MSB: RXDAST <> :MSB: NOACK ; FAST3 => FALSE
 ]
 |
 [ FAST3 <> TRUE
 PAGE OK :MSB: RXDAST = :MSB: NOACK ; FAST3 => TRUE
 ]
 ]

; ********

 [ :MSB: WSOUR <> :MSB: RXDAST
 [ FAST4 = TRUE
 PAGE ERROR :MSB: WSOUR <> :MSB: RXDAST ; FAST4 => FALSE
 ]
 |
 [ FAST4 <> TRUE
 PAGE OK :MSB: WSOUR = :MSB: RXDAST ; FAST4 => TRUE
 ]
 ]

; ********

 [ :MSB: ENPAK <> :MSB: WCLM
 [ FAST5 = TRUE
 PAGE ERROR :MSB: ENPAK <> :MSB: WCLM ; FAST5 => FALSE
 ]
 |
 [ FAST5 <> TRUE
 PAGE OK :MSB: ENPAK = :MSB: WCLM ; FAST5 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCACK <> :MSB: ENPAK
 [ FAST6 = TRUE
 PAGE ERROR :MSB: WSCACK <> :MSB: ENPAK ; FAST6 => FALSE
 ]
 |
 [ FAST6 <> TRUE
 PAGE OK :MSB: WSCACK = :MSB: ENPAK ; FAST6 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKS <> :MSB: WSCACK
 [ FAST7 = TRUE
 PAGE ERROR :MSB: WSCAKS <> :MSB: WSCACK ; FAST7 => FALSE
 ]
 |
 [ FAST7 <> TRUE
 PAGE OK :MSB: WSCAKS = :MSB: WSCACK ; FAST7 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKD <> :MSB: WSCAKS
 [ FAST8 = TRUE
 PAGE ERROR :MSB: WSCAKD <> :MSB: WSCAKS ; FAST8 => FALSE
 ]
 |
 [ FAST8 <> TRUE
 PAGE OK :MSB: WSCAKD = :MSB: WSCAKS ; FAST8 => TRUE
 ]
 ]

; ********

 [ FAST9 = TRUE
 [ :MSB: NOUPDA <> :MSB: TXINFO  
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINFO ; FAST9 => FALSE
 ]
 [ :MSB: NOUPDA <> :MSB: TXINF2
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINF2 ; FAST9 => FALSE
 ]
 |
 [ :MSB: NOUPDA = :MSB: TXINF2
 [ :MSB: NOUPDA = :MSB: TXINFO  
 PAGE OK :MSB: NOUPDA = :MSB: TXINFO ; FAST9 => TRUE
 PAGE OK :MSB: NOUPDA = :MSB: TXINF2 ; FAST9 => TRUE
 ]
 ]
 ]

; ********

 [ :MSB: DATACK <> :MSB: ENPAK
 [ FAST10 = TRUE
 PAGE ERROR :MSB: DATACK <> :MSB: ENPAK ; FAST10 => FALSE
 ]
 |
 [ FAST10 <> TRUE
 PAGE OK :MSB: DATACK = :MSB: ENPAK ; FAST10 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKS <> :MSB: DATACK
 [ FAST11 = TRUE
 PAGE ERROR :MSB: WDAAKS <> :MSB: DATACK ; FAST11 => FALSE
 ]
 |
 [ FAST11 <> TRUE
 PAGE OK :MSB: WDAAKS = :MSB: DATACK ; FAST11 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKD <> :MSB: WDAAKS
 [ FAST12 = TRUE
 PAGE ERROR :MSB: WDAAKD <> :MSB: WDAAKS ; FAST12 => FALSE
 ]
 |
 [ FAST12 <> TRUE
 PAGE OK :MSB: WDAAKD = :MSB: WDAAKS ; FAST12 => TRUE
 ]
 ]

 TTL ROM statistics                            File => LOWL05
 OPT STATSL

; Calculate some ROM stats

NFSLEN * NFSEND - NFSORG ; The length of the NFS
TUBLEN * TUBEND - TUBORG ; The length of the TUBE code
LOWLEN * LOWEND - LOWORG ; The length of the low level code

ZZZZZZ * NFSLEN + TUBLEN + LOWLEN ; The total size
ROMORG * NFSORG ; For saving on to disc
ROMEND * NFSORG + &4000

 END

