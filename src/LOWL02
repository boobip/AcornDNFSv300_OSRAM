 TTL Receive routines.                         File > LOWL02
 OPT RXRTNS

;RECEIVE ROUTINES
;THIS IS THE CODE NEEDED TO RECEIVE AN ECONET MESSAGE
;A SCOUT MESSAGE IS RECEIVED
;IF THIS IS CORRECT AN ACKNOWLEDGE IS TRANSMITED
;A DATA PACKET IS AWAITED
;THE DATA PACKET IS LOADED INTO MEMORY
;THE DATA PACKET IS ACKNOWLEDGED.
;
; ****** NEVER fall through here ************
;

REC
 LDAIM AP
 BIT SReg2  ;CHECK FOR ADDRESS PRESENT
 BEQ RXSERR ;AP EXPECTED
 LDA RXBYTE
 CMP STNID ;TEST DESTLO FOR STATION MATCH
 BEQ TESTHI
 CMPIM BDCAST  ;TEST DESTLO FOR BRCAST MATCH
 BNE FRDISC
 LDAIM BCAST
 STA NSTATE ;FLAG BROADCAST MESSAGE

TESTHI
 LDAIM :LSB: RXDEHI
 [ FAST1 <> TRUE
 LDYIM :MSB: RXDEHI
 JMP WRXINT
 |
 JMP WRXNTF ; New fast code !
 ]
 
RXDEHI
 BIT SReg2
 BPL RXSERR ;RXDA EXPECTED N.B IN 2BYTE MODE
 LDA RXBYTE
 BEQ FORUS ;NET NUMBER MUST BE ZERO
 EORIM BDCAST ;TEST DESTHI FOR NETWORK BROADCAST
 BEQ FORUSB
 
FRDISC ;FRAME DISCONTINUE
 LDAIM &A2  ;+TXRS -RXRS +FRDSC -TDSR -RDSR -TIE +RIE CR2
 STA CReg1
 JMP NOUPD3 ;WAIT FOR ANOTHER RXINT

FORUS ;NOT BROADCAST FOR US
 STA NSTATE
FORUSB ;BROADCAST FOR US
 STA RXYOFF
 LDAIM :LSB: RXHEAD
 [ FAST2 <> TRUE
 LDYIM :MSB: RXHEAD
 JMP WRXINT
 |
 JMP WRXNTF ; New fast code !
 ]

;RESET RECEIVER FOR MORE PACKETS
RXSERR
 LDA SReg2
 ANDIM &81
 BEQ NORST
 JSR CPINIT ;REINIT THE CHIP
 JMP NOUPD3
NORST
 JMP NOUPD2 ;RESET CHIP AND WAIT FOR ANOTHER RXINIT

;THIS LOOP BUFFERS THE SCOUT PACKET IN THE SCOUT BUFFER
RXHEAD       ;RECEIVE PACKET: CNTRL,PORT,2DEST
 LDY RXYOFF ;LOAD COUNT
 LDA SReg2
RXHED2
 BPL RXSERR ;RXDA EXPECTED N.B. IN 2 BYTE MODE.SCOUT IS EVEN
 LDA RXBYTE
 STAAY SCOUTB
 INY
 LDA SReg2
 BMI PASS3 ;2BYTES STILL AVAILABLE
 BNE SBUFEN ;END OF SCOUT PACKET E.G. FV CONDITION
PASS3
 LDA RXBYTE
 STAAY SCOUTB
 INY ;INCREMENT COUNT
 CPYIM SBSIZE ;TEST COUNT
 BEQ SBUFEN
 STY RXYOFF ;STORE COUNT
 LDA SReg2
 BNE RXHED2
 JMP WRXIN2 ;WE HAVE ALREADY STORED JUMP VECTOR



;CLAIM LINE WITH FLAGS
SBUFEN
 LDAIM ZERO  ;-TXRST -RXRST -RXDISC -TDSR -RDSR -TIE -RIE SCR2
 STA CReg1
 LDAIM &84  ;+RTS -CTXST -CRXST -TXLAST TDRA FLAG 1-BYT -PSE
 STA CReg2 ;SWITCH TO 1-BYTE MODE PAD WITH FLAGS

;CHECK FOR OK CRC
 LDAIM FV
 BIT SReg2
 BEQ RXSERR ;BAD CRC

;CHECK FOR UNREAD DATA BYTE
 BPL RXSERR ;NOT ONE MORE EXTRA BYTE
 LDA RXBYTE
 STAAY SCOUTB ;STORE LAST BYTE OF SCOUT BUFFER
 LDAIM &44  ;-TXRST +RXRST -RXDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1

;CHECK FOR IMMEDIATE OPERATION
 SEC
 ROR TUBLOK ;SET TUBE LOCK FLAG
 LDA SBPORT
 BNE NOIMED
 JMP RXIMED ;PROCESS IMMEDIATE OPERATION


NOIMED
;SWITCH OFF TX IF BROADCAST
 BIT NSTATE
 BVC NOBRD
 LDAIM SEVEN ; -RTS -CTXST -CRXST -TXLAST TDRA FLAG 2-BYT +PSE
 STA CReg2 ;TURN OFF TX
NOBRD
;CHECK WHETHER AN RX CONTROL BLOCK EXISTS
 BIT SSTATE
 BPL USERCB ;NO NFS RXCB,TEST FOR USER CONTROL BLOCKS

;FIND A MATCHING RXCBLOCK
 LDAIM :LSB: RXCB
 LDYIM :MSB: RXCB
FNDLP1
 STA RXCBPT
 STY RXCBPT + ONE ;LOAD UP TO POINT TO NFS CONTROL BLOCKS
FINDLP
 LDYIM ZERO
 LDAIY RXCBPT
 BEQ RXSCER ;TERMINATOR FOUND IN USER CBLOCKS
 CMPIM RXRDY ;VALID RECEIVE CONTROL BYTE
 BNE NOMACH
 INY  ;INCREMENT TO PORT
 LDAIY RXCBPT
 BEQ PMATCH ;WILDCARD ZERO PORT ID
 CMP SBPORT
 BNE NOMACH ;NO PORT MATCH
PMATCH
 INY ;INCR TO STATION LO
 LDAIY RXCBPT
 BEQ MATCHl ; ****** Bruce 27/2/86 ******* SLOMAT ;WILDCARD ZERO STATION ID
 CMP SBSRLO
 BNE NOMACH ;NO STATION LO MATCH
SLOMAT
 INY
 LDAIY RXCBPT
 CMP SBSRHI
 BEQ MATCHl ;NO STATION HI MATCH
NOMACH ; Get past pointer locations
 LDA RXCBPT + ONE ; Test to see if USER or NFS
 BEQ USERCB ; Was in zero page so it was NFS
 LDA RXCBPT
 CLC
 ADCIM &0C ;POINT TO NEXT RXCB
 STA RXCBPT
 BCC FINDLP ;RXCB SPACE EXHAUSTED AND NO MATCH

RXSCER  ;ERROR IN SCOUT PACKET
 JMP RXDERR

USERCB
 BIT SSTATE ;CHECK BIT 4
 BVC RXSCER
 LDAIM ZERO
 LDY DYNVC2 + ONE ;POINT TO 2ND PAGE DYNAMIC WORKSPACE
 BNE FNDLP1

MATCHl
;CALCULATE DATA POINTERS I.E. TRANSLATION
; BIT NSTATE ;CHECK FOR BROADCAST
; BVC NOBRDC
; JMP BRDUP
NOBRDC

 LDAIM THREE ;REG A INDICATES DOUBLE BYTE WRITE OPERATION
 STA TDIR ;INDICATE A WRITE TO TUBE
 JSR ADCALC
; BCS CLMOKK ;NO TUBE CLAIM ERROR
 BCC RXDERR ; There was a TUBE claim error !

 BIT NSTATE ; Check for broadcast RX
 BVC CLMOKK ; If not then as normal
 JMP BRDRX ; Recieve a broadcast

CLMOKK

;ACKNOWLEDGE SCOUT PACKET N.B. DONT HAVE TO CLAIM
ACKSCO
 LDAIM &44  ;-TXRST +RXRST -RXDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM &A7  ;+RTS -CTXST +CRXST -TLAST TDRA FLAG 2-BYT +PSE
 STA CReg2
 LDAIM :LSB: NOACK
 LDYIM :MSB: NOACK
 JMP TXACK

NOACK
 LDAIM &82  ;+TXRST -RXRST -RXDISC -TDSR -RDSR -RDSR -TIE +RIE SCR2
 STA CReg1

 LDAIM :LSB: RXDAST
 [ FAST3 <> TRUE
 LDYIM :MSB: RXDAST
 JMP WRXINT
 |
 JMP WRXNTF ; New fast code !
 ]

;RECEIVE DATA PACKET
RXDAST
 LDAIM AP
 BIT SReg2  ;CHECK FOR ADDRESS PRESENT
 BEQ RXDERR ;ADDR PRESENT EXPECTED
 LDA RXBYTE
 CMP STNID ;TEST DESTLO FOR STATION MATCH
 BNE RXDERR ;DATA PACKET NOT FOR US. DISC PACKET
;TSTHI
 LDAIM :LSB: WSOUR
 [ FAST4 <> TRUE
 LDYIM :MSB: WSOUR
 JMP WRXINT ;WAIT FOR 2BYTES OF DATA
 |
 JMP WRXNTF ; New fast code !
 ]

WSOUR
 BIT SReg2
 BPL RXDERR ;RXDA EXPECTED N.B IN 2BYTE MODE
 LDA RXBYTE ;NET NUMBER MUST BE ZERO
 BNE RXDERR ;DATA PACKET NOT FOR US
 LDAIM :LSB: WDEST
 LDYIM :MSB: WDEST
 BIT SReg1 ;QUICK IRQ POLL
 BMI WDEST
 JMP WRXINT

WDEST
 BIT SReg2
 BPL RXDERR ;RXDA EXPECTED
 LDA RXBYTE ;READ 2 DEST BYTES
 LDA RXBYTE ;CHECK AGAINST SCOUT BUFF IF SECURITY NEEDED
RXINF
 LDAIM TUBEf
 BIT NSTATE
 BNE ISTUBE
 LDAIM :LSB: AGAIN
 LDYIM :MSB: AGAIN
 BIT SReg1 ;QUICK IRQ POLL
 BMI AGAIN
 JMP WRXINT
ISTUBE
 LDAIM :LSB: AGAIN2
 LDYIM :MSB: AGAIN2
 JMP WRXINT

;RECEIVE DATA PACKET ERROR
RXDERR
;RESET RECEIVER FOR MORE PACKETS
 LDA NSTATE
 BPL NLACK ;BRANCH IF NO LONG ACK
 JMP TXBER1 ;REPORT TRANSMIT ERROR
NLACK
 JSR CPINIT ;FLUSH OUT ANY REMAINING BYTES
 JMP NOUPDA

AGAIN
 LDY RXYOFF ;LOAD COUNT
 LDA SReg2
AGAIN4
 BPL RXEND ;RDA EXPECTED N.B IN 2-BYTE MODE
 LDA RXBYTE
 STAIY RXDAPT
 INY
 BNE PASS
 INC RXDAPT + ONE
 DEC RXPAGE
 BEQ RXDERR ;ERROR BUFFER FULL BUT ONE MORE BYTE
PASS
 LDA SReg2
 BMI PASS8
 BNE RXEND
PASS8
 LDA RXBYTE
 STAIY RXDAPT
 INY
 STY RXYOFF
 BNE OUTK

UPCONT
 INC RXDAPT + ONE
 DEC RXPAGE
 BEQ RXEND ;IS THIS AN ERROR?
OUTK
 LDA SReg2 ;QUICK IRQ POLL
 BNE AGAIN4
 JMP WRXIN2


;CHECK UNREAD DATA BYTE,CRC ETC.
RXEND
 LDAIM &84  ;+RTS -CTXST -CRXST -TLAST TDRA FLAG 1BYTE -PSE
 STA CReg2 ;SWITCH TO 1-BYTE FOR LATER 1 BYTE TEST
 LDAIM ZERO  ;-TXRS -RXRS -FDISC -TDSR -RDSR -TIE -RIE SCR2
 STA CReg1
 STY RXYOFF
 LDAIM FV ;CHECK CRC
 BIT SReg2
 BEQ RXDERR ;PACKET CRC BAD

 BPL NOBYT ;CHECK UNREAD BYTE
 LDA RXPAGE
BCXXX1 BEQ RXDERR ;FRAME TOO LONG, NOW BEING BRANCHED THROUGH
 LDA RXBYTE ;READ EXTRA BYTE
 LDY RXYOFF
 STAIY RXDAPT
 INC RXYOFF ;UPDATE POINTERS
 BNE NOBYT
 INC RXDAPT + ONE
NOBYT
 JMP NOBYT2



AGAIN2
 LDA SReg2
AGAIN3
 BPL RXEND2 ;RXDA EXPECTED
 LDA RXBYTE
 JSR INCRXP
 BEQ BCXXX1 ; RXDER2, RXDERR is the real destination
 STA R3DATA

CONTIN
 LDA RXBYTE
 STA R3DATA
 JSR INCRXP
 BEQ RXEND2
OUTT
 LDA SReg2 ;QUICK IRQ POLL TO SAVE STACK WORK
 BNE AGAIN3
 JMP WRXIN2

;RXDER2
; JMP RXDERR

RXEND2
;CHECK UNREAD DATA BYTE,CRC ETC.
 LDAIM ZERO  ;-TXRS -RXRS -FDISC -TDSR -RDSR -TIE -RIE SCR2
 STA CReg1
 LDAIM &84  ;+RTS -CTXST -CRXST -TLAST TDRA FLAG 1BYTE -PSE
 STA CReg2 ;SWITCH TO 1-BYTE FOR LATER 1 BYTE TEST
 LDAIM FV ;CHECK CRC
 BIT SReg2
 BEQ BCXXX1 ; RXDER2 ;PACKET CRC BAD, RXDERR is destination

 BPL NOBYT2 ;CHECK UNREAD BYTE
 LDA RXYOFF ;CHECK IF FRAME TOO LONG
 ORA RXPAGE
 ORA RXDAPT
 ORA RXDAPT + ONE
 BEQ BCXXX1 ; RXDER2 ;TUBE FRAME TOO LONG, RXDERR is destination
 LDA RXBYTE ;N.B. CHECK COUNTERS!!!!!
 STA LSTBYT
 LDAIM ONEBYT
 ORA NSTATE
 STA NSTATE

NOBYT2  ;UPDATE RXDAPT TO POINT TO DATA END
NOPAGE
 LDA NSTATE ;CHECK FOR LONG ACK PACKET
 BPL TXAK
 JSR LASTBY ;PUT LAST BYTE UP TUBE IF ANY
 JMP UPTXCB ;UPDATE TXCBLOCK

TXAK
;ACKNOWLEDGE DATA PACKET
 LDAIM &44  ;-TXRST +RXRST -RXDISC -TDSR -RDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM &A7  ;+RTS -CTXST +CRXST -TLAST TDRA MARK 2-BYT +PSE
 STA CReg2
 LDAIM :LSB: UPDATE
 LDYIM :MSB: UPDATE

;TRANSMIT AN ACKNOWLEDGEMENT PACKET
TXACK
 STA TXLINK
 STY TXLINK + ONE  ;SAVE SUBROUTINE LINKAGE
;TX 2BYTES DESTINATION
 LDA SBSRLO
 BIT SReg1
 BVC RXAERR ;TDRA EXPECTED N.B. IN 2 BYTE MODE
 STA TXBYTE ;TRANSMIT SOURCE LO
 LDA SBSRHI
 STA TXBYTE ;TRANSMIT SOURCE HI
 LDAIM :LSB: TXACKS
 LDYIM :MSB: TXACKS
 JMP WTXINT ;WAIT FOR TX INTERUPT

TXACKS   ;TX 2BYTES SOURCE
 LDA STNID
 BIT SReg1
 BVC RXAERR ;TDRA EXPECTED N.B. IN 2-BYTE MODE
 STA TXBYTE
 LDAIM NETnum
 STA TXBYTE
 LDA NSTATE
 BMI NOEND
;END PACKET TRANSMISSION
 LDAIM &3F ;-RTS -CTXST +CRXST +TXLST FC FLAG 2-BYT +PSE
 STA CReg2
 LDA TXLINK
 LDY TXLINK + ONE
 JMP WTXINT ;WAIT FOR TX INTERUPT FC EVENT AND RETURN TO CALLER
NOEND
 JMP TXINF ;FOR LONG ACK

;ERROR IN TRANSMITTING AN ACK PACKET
RXAERR
;RESET RECEIVER FOR MORE PACKETS
 JMP RXDERR

LASTBY
 LDAIM TUBEf ;IF TUBE TERMINATE CHANNEL
 BIT NSTATE
 BEQ TOUT2 ;EXIT AND FLAG  T.UPDATE NOT DONE
; .N.B. DO 32 BIT UPDATE
 CLC
 PHP
 LDYIM CBEALO
LOOPIN
 LDAIY RXCBPT
 PLP
 ADCAY RXYOFF -CBEALO
 STAIY RXCBPT
 INY
 PHP
 CPYIM XTRA1L
 BCC LOOPIN
 PLP

 LDAIM ONEBYT
 BIT NSTATE
 BEQ TOUT1

 TXA
 PHA
 LDAIM CBEALO
 CLC
 ADC RXCBPT
 TAX
 LDY RXCBPT + ONE
 LDAIM ONE; ONE BYTE WRITE
 JSR tADDRl
 LDA LSTBYT
 STA R3DATA
 SEC
 LDYIM CBEALO
TINC4
 LDAIM ZERO
 ADCIY RXCBPT
 STAIY RXCBPT
 INY
 BCS TINC4


 PLA
 TAX
TOUT1
 LDAIM &FF
TOUT2
 RTS



;UPDATE RECEIVE CONTROL BLOCK
UPDATE
 LDA SBPORT
 BNE NOTIMM ;DONT UPDATE RXCB IF IMMED OPERATION
 LDY SBCNTL
 CPYIM IPOKE
 BEQ NOTIMM
 JMP ENDIM

NOTIMM
 JSR LASTBY ;LAST BYTE TUBE WRITE
 BNE CBUUPD ;BRANCH IF UPDATE DONE ALREADY
NOTTUB
 LDA RXYOFF
 CLC  ;CALC BUFFER END
 ADC RXDAPT
 BCC NOPGE
 INC RXDAPT + ONE

NOPGE
 LDYIM CBEALO
 STAIY RXCBPT ;UPDATE BUFFER END LO
 INY
 LDA RXDAPT + ONE ;UPDATE BUFFER END HI
 STAIY RXCBPT
 
CBUUPD
 LDA SBPORT
 BEQ NOUPDA ;IM PEEK OPERATION CHECK
 LDA SBSRHI ;UPDATE SOURCE HI
 LDYIM CBSRHI
 STAIY RXCBPT
 DEY

 LDA SBSRLO ;UPDATE SOURCE LO
 STAIY RXCBPT
 DEY

 LDA SBPORT ;UPDATE PORT
 STAIY RXCBPT
 DEY

 LDA SBCNTL ;UPDATE CONTROL BYTE
 ORAIM &80 ;SET TOP BIT
 STAIY RXCBPT


NOUPDA
 LDAIM TUBEf ;TEST IF WE HAVE BEEN TUBING
 AND TUBEFL ;MAKE FUCKING SURE THERE IS A TUBE
 BIT NSTATE
 BEQ NOUPD2
 JSR TUBREL
NOUPD2
 JSR CPRST
NOUPD3
 LDAIM :LSB: REC
 LDYIM :MSB: REC
 JMP WRXINT

;BRDUP ; The original broadcast RX
; LDYIM CBSALO
;BRDLP
; LDAAY SCOUTB 
; STAIY RXCBPT
; INY
; CPYIM &0C ;COMPARE TO END OF CONTROL BLOCK
; BNE BRDLP
; JMP CBUUPD

BRDRX ; The new broadcast reception
 TXA
 PHA
 LDXIM CBSALO
 LDAIM TUBEf ; Also set Z flag on Tube state
 BIT NSTATE ; Do the check
 BNE TUBRDC
IOBRDC
 LDY RXYOFF

IOBRC1
 LDAAX SCOUTB
 STAIY RXDAPT
 INY
 BNE IOBRC2
 INC RXDAPT + ONE
 DEC RXPAGE
 BEQ BRCER1 ; Remember to pull X first
IOBRC2
 INX
 STY RXYOFF
 CPXIM CBSALO + EIGHT
 BNE IOBRC1
BRDCT1
 PLA
 TAX
 JMP NOTIMM

TUBRDC
 LDAAX SCOUTB
 STA R3DATA
 JSR INCRXP
 BEQ BRCERR
TUBRC2
 INX
 CPXIM CBSALO + EIGHT
 BNE TUBRDC
 BEQ BRDCT1

TUBREL
 BIT TUBLOK
 BMI NOREL
 LDAIM &82 ;RELEASE TUBE
 JSR tADDRl
NOREL
 LSR TUBLOK
 RTS

INCRXP
 INC RXYOFF ; Increment the 4 byte pointer
 BNE INCRXX
 INC RXPAGE
 BNE INCRXX
 INC RXDAPT
 BNE INCRXX
 INC RXDAPT + ONE
INCRXX
 RTS


;PROCESS IMMEDIATE OPERATION
RXIMED
 LDY SBCNTL
 CPYIM IPEEK
 BCC IMERR
 CPYIM IMACH + ONE
 BCS IMERR ;RANGE CHECK
 CPYIM ISTRT
 BCS PRIVST ;NO PROTECTION FOR LAST TWO IM OPS

 TYA
 SEC
 SBCIM IPEEK
 TAY
 LDA IMASK
FINDIM
 RORA
 DEY
 BPL FINDIM
 BCS NOUPD2 ;PROTECTED FROM IM OPERATION

PRIVST
 LDY SBCNTL
 ;LDAAY JMPIMH -IPEEK ;NIFTY CASE INSTUCTION
 LDAIM JMPIMH
 PHA
 LDAAY JMPIML -IPEEK
 PHA
 RTS

BRCER1
 INC RXYOFF
BRCERR ; The error in broadcast
 CPXIM CBSALO + SEVEN
 BEQ BRDCT1
 PLA
 TAX

IMERR
 JMP RXDERR

JMPIML  ;IMMED OP JUMP TABLE
 = RXPEEK - ONE
 = RXPOKE - ONE
 = RXRTN - ONE
 = RXPROE - ONE
 = RXPROH - ONE
 = RXSTOP - ONE
 = RXSTRT - ONE
 = RXMACH - ONE

RXRTN
RXPROE
RXPROH
 LDAIM ZERO
 STA RXDAPT
 LDAIM PROBUF
 STA RXYOFF
 LDAIM ONE
 STA RXPAGE
 LDA DYNVC1 + ONE ;POINT TO DYNAMIC WORKSPACE
 STA RXDAPT + ONE
 LDYIM THREE ;LOAD COUNTER
MORSTR
 LDAAY SBADT1
 STAAY IRQSTR + ONE
 DEY
 BPL MORSTR ;SAVE SCOUT BUFF VARIABLES COS IRQ IS VERY VERY SLOW
 JMP ACKSCO

RXPOKE
 LDAIM :LSB: SCOUTB
 STA RXCBPT
 LDAIM :MSB: SCOUTB ;MAKE RXCBPT POINT TO SCOUT BUFFER
 STA RXCBPT + ONE
 JMP NOBRDC
RXMACH
 LDAIM ONE ;ONE PAGE
 STA RXPAGE
 LDAIM &100 - MSIZE ;POINT TO MACHINE PEEK AREA
 STA RXYOFF
 LDAIM :LSB: (MCPEEK + MSIZE - &100)
 STA RXDAPT
 LDAIM :MSB: (MCPEEK + MSIZE - &100)
 STA RXDAPT + ONE
 [ ZERO = :MSB: (MCPEEK + MSIZE - &100)
 BEQ SENDIT
 |
 BNE SENDIT
 ]


RXPEEK
;CALCULATE RXDAPT RXYOFF RXPAGE 
 LDAIM :LSB: SCOUTB ;MAKE RXCBPT POINT TO SCOUT BUFFER
 STA RXCBPT
 LDAIM :MSB: SCOUTB
 STA RXCBPT + ONE
 LDAIM TWO ;DOUBLE BYTE WRITE
 STA TDIR
 JSR ADCALC
 BCC EXITIM ;TUBE CLAIM FAILED
SENDIT
 LDA NSTATE ;SET LONG ACK FLAG
 ORAIM &80
 STA NSTATE ;NOTE AFTER TXACK THE JUMP BACK IS DIRECT

RXSTOP
RXSTRT
 LDAIM &44  ;-TXRST +RXRST -FDISC -TDSR -RDSR +TIE -RIE SCR2
 STA CReg1
 LDAIM &A7  ;+RTS -CTXST +CRXST -TXLD TDRA FLAG 2BYT +PSE
 STA CReg2  ;ENABLE TRANSMIT
 LDAIM :LSB: CIRQ
 LDYIM :MSB: CIRQ
 JMP TXACK

ENDIM
;RESTORE RXDAPT TO POINT TO PROCEDURE BUFFER

 LDA RXYOFF ;CALC PARAMETER SIZE
 CLC
 ADCIM &100 -PROBUF +&02 ;TWO ALLOWS FOR STATION NUMBER
 LDYIM BUFCNT
 STAIY DYNVC1 ;UPDATE BUFFER COUNT

 LDYIM STNNO
 LDA SBSRLO
 STAIY DYNVC1
 INY
 LDA SBSRHI
 STAIY DYNVC1 ;STORE CALLING STATION NUMBER

;CAUSE IRQ
CIRQ
 LDA SBCNTL
 STA IRQSTR ;SAVE SCOUT BUF VARIABLES COS IRQ SLOW
 LDAIM &84
 STA VIA +&E ;ENABLE SHIFT INT,IER REG
 LDA VIA +&B ;SHIFT CONTROL BY SYSTEM CLOCK,ACR REG
 ANDIM &1C
 STA STORE ;SAVE BITS 2,3,4
 LDA VIA +&B ;ACR REG
 ANDIM &E3
 ORAIM EIGHT
 STA VIA +&B ;ACR REG
 BIT VIA +&A ;READ TRIGGERS SHIFT OPERATION,SR REG
EXITIM
 JMP NOUPD2 ;GOBACK TO NORMAL RECEIVE MODE
 
; The "LOWINT" routine has been moved to LOWL01 !!!!!!!

JMPI2L  ;IMMED OP LO BYTE JUMP TABLE
 = RXRTN2 - ONE
 = RXPRE2 - ONE
 = RXPRH2 - ONE
 = RXSTP2 - ONE
 = RXSTR2 - ONE

RXRTN2
 LDAIM :MSB: (OUT - ONE)
 PHA
 LDAIM :LSB: (OUT - ONE) ;NOTE TUBE JSR IS NOT ALLOWED
 PHA
 JMI IRQSTR + ONE ;NON TUBE TYPE ROUTINE CALL

RXPRE2
 LDYIM EIGHT
 LDX IRQSTR + ONE
 LDA IRQSTR + TWO
 JSR OSEVEN ;CAUSE EVENT, ON EVENT X,Y HAS PROCEDURE NUMBER
 JMP OUT

RXPRH2 ;JUMP TO NFS
 LDX IRQSTR + ONE
 LDY IRQSTR + TWO ;LOAD X AND Y WITH PROC NUMBER
 JSR USRPRC
 JMP OUT

RXSTP2
 LDAIM STOP
 BIT SSTATE
 BNE OUT
 ORA SSTATE ;FLAG PROCESSOR IS STOPPED
 STA SSTATE
 LDAIM STOP
 CLI ;ENABLE INTERUPT
TSTSTP
 BIT SSTATE
 BNE TSTSTP ;LOOP UNTIL BIT RESET
 BEQ OUT

RXSTR2
 LDA SSTATE
 ANDIM &FF -STOP
 STA SSTATE ;CLEAR STOPPED STATE

OUT
 PLA
 TAY
 PLA
 TAX
OUT2
 LDAIM ZERO ;CLAIM IRQ
 RTS

 LNK LOWL03

H <> :MSB: (RXPOKE - ONE)
 PAGE ERROR RXPOKE
 ]
 [ JMPIMH <> :MSB: (RXRTN - ONE)
 PAGE ERROR RXRTN
 ]
 [ JMPIMH <> :MSB: (RXPROE - ONE)
 PAGE ERROR RXPROE
 ]
 [ JMPIMH <> :MSB: (RXPROH - ONE)
 PAGE ERROR RXPROH
 ]
 [ JMPIMH <> :MSB: (RXSTOP - ONE)
 PAGE ERROR RXSTOP
 ]
 [ JMPIMH <> :MSB: (RXSTRT - ONE)
 PAGE ERROR RXSTRT
 ]
 [ JMPIMH <> :MSB: (RXMACH - ONE)
 PAGE ERROR RXMACH
 ]



JMPI2H * :MSB: (RXRTN2 - ONE)
 [ JMPI2H <> :MSB: (RXPRE2 - ONE)
 PAGE ERROR RXPRE2
 ]
 [ JMPI2H <> :MSB: (RXPRH2 - ONE)
 PAGE ERROR RXPRH2
 ]
 [ JMPI2H <> :MSB: (RXSTP2 - ONE)
 PAGE ERROR RXSTP2
 ]
 [ JMPI2H <> :MSB: (RXSTR2 - ONE)
 PAGE ERROR RXSTR2
 ]



TXIMH * :MSB: (PEEKIT - ONE)
 [ TXIMH <> :MSB: (POKEIT - ONE)
 PAGE ERROR POKEIT
 ]
 [ TXIMH <> :MSB: (RTNIT - ONE)
 PAGE ERROR RTNIT
 ]
 [ TXIMH <> :MSB: (PROEIT - ONE)
 PAGE ERROR PROEIT
 ]
 [ TXIMH <> :MSB: (PROHIT - ONE)
 PAGE ERROR PROHIT
 ]
 [ TXIMH <> :MSB: (STOPIT - ONE)
 PAGE ERROR STOPIT
 ]
 [ TXIMH <> :MSB: (STRTIT - ONE)
 PAGE ERROR STRTIT
 ]
 [ TXIMH <> :MSB: (MACHIT - ONE)
 PAGE ERROR MACHIT
 ]

; ********

 [ :MSB: RXDEHI <> :MSB: REC
 [ FAST1 = TRUE
 PAGE ERROR :MSB: RXDEHI <> :MSB: REC ; FAST1 => FALSE
 ]
 |
 [ FAST1 <> TRUE
 PAGE OK :MSB: RXDEHI = :MSB: REC ; FAST1 => TRUE
 ]
 ]

; ********

 [ :MSB: RXHEAD <> :MSB: RXDEHI
 [ FAST2 = TRUE
 PAGE ERROR :MSB: RXHEAD <> :MSB: RXDEHI ; FAST2 => FALSE
 ]
 |
 [ FAST2 <> TRUE
 PAGE OK :MSB: RXHEAD = :MSB: RXDEHI ; FAST2 => TRUE
 ]
 ]

; ********

 [ :MSB: RXDAST <> :MSB: NOACK
 [ FAST3 = TRUE
 PAGE ERROR :MSB: RXDAST <> :MSB: NOACK ; FAST3 => FALSE
 ]
 |
 [ FAST3 <> TRUE
 PAGE OK :MSB: RXDAST = :MSB: NOACK ; FAST3 => TRUE
 ]
 ]

; ********

 [ :MSB: WSOUR <> :MSB: RXDAST
 [ FAST4 = TRUE
 PAGE ERROR :MSB: WSOUR <> :MSB: RXDAST ; FAST4 => FALSE
 ]
 |
 [ FAST4 <> TRUE
 PAGE OK :MSB: WSOUR = :MSB: RXDAST ; FAST4 => TRUE
 ]
 ]

; ********

 [ :MSB: ENPAK <> :MSB: WCLM
 [ FAST5 = TRUE
 PAGE ERROR :MSB: ENPAK <> :MSB: WCLM ; FAST5 => FALSE
 ]
 |
 [ FAST5 <> TRUE
 PAGE OK :MSB: ENPAK = :MSB: WCLM ; FAST5 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCACK <> :MSB: ENPAK
 [ FAST6 = TRUE
 PAGE ERROR :MSB: WSCACK <> :MSB: ENPAK ; FAST6 => FALSE
 ]
 |
 [ FAST6 <> TRUE
 PAGE OK :MSB: WSCACK = :MSB: ENPAK ; FAST6 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKS <> :MSB: WSCACK
 [ FAST7 = TRUE
 PAGE ERROR :MSB: WSCAKS <> :MSB: WSCACK ; FAST7 => FALSE
 ]
 |
 [ FAST7 <> TRUE
 PAGE OK :MSB: WSCAKS = :MSB: WSCACK ; FAST7 => TRUE
 ]
 ]

; ********

 [ :MSB: WSCAKD <> :MSB: WSCAKS
 [ FAST8 = TRUE
 PAGE ERROR :MSB: WSCAKD <> :MSB: WSCAKS ; FAST8 => FALSE
 ]
 |
 [ FAST8 <> TRUE
 PAGE OK :MSB: WSCAKD = :MSB: WSCAKS ; FAST8 => TRUE
 ]
 ]

; ********

 [ FAST9 = TRUE
 [ :MSB: NOUPDA <> :MSB: TXINFO  
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINFO ; FAST9 => FALSE
 ]
 [ :MSB: NOUPDA <> :MSB: TXINF2
 PAGE ERROR :MSB: NOUPDA <> :MSB: TXINF2 ; FAST9 => FALSE
 ]
 |
 [ :MSB: NOUPDA = :MSB: TXINF2
 [ :MSB: NOUPDA = :MSB: TXINFO  
 PAGE OK :MSB: NOUPDA = :MSB: TXINFO ; FAST9 => TRUE
 PAGE OK :MSB: NOUPDA = :MSB: TXINF2 ; FAST9 => TRUE
 ]
 ]
 ]

; ********

 [ :MSB: DATACK <> :MSB: ENPAK
 [ FAST10 = TRUE
 PAGE ERROR :MSB: DATACK <> :MSB: ENPAK ; FAST10 => FALSE
 ]
 |
 [ FAST10 <> TRUE
 PAGE OK :MSB: DATACK = :MSB: ENPAK ; FAST10 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKS <> :MSB: DATACK
 [ FAST11 = TRUE
 PAGE ERROR :MSB: WDAAKS <> :MSB: DATACK ; FAST11 => FALSE
 ]
 |
 [ FAST11 <> TRUE
 PAGE OK :MSB: WDAAKS = :MSB: DATACK ; FAST11 => TRUE
 ]
 ]

; ********

 [ :MSB: WDAAKD <> :MSB: WDAAKS
 [ FAST12 = TRUE
 PAGE ERROR :MSB: WDAAKD <> :MSB: WDAAKS ; FAST12 => FALSE
 ]
 |
 [ FAST12 <> TRUE
 PAGE OK :MSB: WDAAKD = :MSB: WDAAKS ; FAST12 => TRUE
 ]
 ]

 TTL ROM statistics                            File => LOWL05
 OPT STATSL

; Calculate some ROM stats

NFSLEN * NFSEND - NFSORG ; The length of the NFS
TUBLEN * TUBEND - TUBORG ; The length of the TUBE code
LOWLEN * LOWEND - LOWORG ; The length of the low level code

ZZZZZZ * NFSLEN + TUBLEN + LOWLEN ; The total size
ROMORG * NFSORG ; For saving on to disc
ROMEND * NFSORG + &4000

 END

